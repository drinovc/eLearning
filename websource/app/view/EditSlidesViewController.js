/*
 * File: app/view/EditSlidesViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.3.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.5.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.5.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('eLearning.view.EditSlidesViewController', {
	extend: 'Ext.app.ViewController',
	alias: 'controller.editslides',

	load: function(opts) {
		var me = this,
			refs = me.getReferences();

		opts = Ext.applyIf(opts || {}, {
			program: null
		});


		if(!App.personId){
			App.personId = -1;
			console.warn("Using mockup test person id");
		}


		me.programData = opts.program.data; // create variable of this program that can be accessed from anywhere in this controller
		me.programId = opts.program.id; //

		refs.panelHeader.setTitle(me.programData.name);

		// clear old panel if there is no slides on this program yet, so content from previous program doesn't remain on this one
		this.clearSlidePanel();
		me.allComponents = []; // clear old components - this array is used to store all ext components of this slide
		me._selectedComponents = [];
		me.clean(true);

		// call sync state here and not save state, as we dont have anything to save yet
		var me = this,
			localStorageData = Ext.decode(localStorage.getItem('mxp_elearning')),
			treeStoreSlides = me.getStore('TreeStoreSlides'),
			questionsStoreSlides = me.getStore('QuestionsStoreSlides'),
			personAnswersStore = me.getStore('PersonAnswers'),
			btnPreview = Ext.getCmp('btnPreview');

		// init subfolders it they are not yet
		if(!localStorageData[me.programId].slides){localStorageData[me.programId].slides = {};}
		if(!localStorageData[me.programId].questions){localStorageData[me.programId].questions = {};}
		if(!localStorageData[me.programId].answers){localStorageData[me.programId].answers = {};}
		localStorageData[me.programId].pageSetup = Ext.applyIf(localStorageData[me.programId].pageSetup, me._pageSetup );

		localStorage.setItem('mxp_elearning', Ext.encode(localStorageData)); // initializes localstorage if it is empty, otherwise overwrites it with same content


		// loaded latest person program so we can see if we can resume current program - color button to indicate that personProgram is still active

		var me = this,
			refs = me.getReferences(),
			personProgramsStore = me.getStore('PersonPrograms'),
			personAnswersStore = me.getStore('PersonAnswers');

		// reset button to default
		var btnPreview = Ext.getCmp('btnPreview');
		btnPreview.removeCls('active-program');
		btnPreview.setText('Preview');

		if(me.programData.validTo < new Date()){
			Ext.toast("Program is not valid anymore!");
			btnPreview.setText('Program Not Valid');
			return;
		}

		if (navigator.onLine){
			var syncAnswersCallback = function(){
				me.setInitialSlide();


				// this code below is causing sections to resync with server - in order to correctly append children to them and show folder icons
				var treeStoreSlides = me.getStore("TreeStoreSlides");
				for(var i = 0; i < treeStoreSlides.data.items.length;i++){
					var entry = treeStoreSlides.data.items[i];
					if(entry.data.categoryId == App.ProgramPageCategoriesEnum.Chapter){
						entry.phantom = true;
					}
				}

				me.saveState(); // save ALL data that is after all initial data syncs to localstorage
				// set initial data

			};

			personProgramsStore.load({
				params:{
					personId: App.personId,
					programId: me.programId
				},
				callback:function(record){
					if(record && record.length > 0){
						me.currentPersonProgram = record[0].data;
						if(me.currentPersonProgram.attempt >= me.programData.maxAttemptsTrainingMode + me.programData.maxAttemptsScoreMode){
							// Cannot attempt any more tries... returning

							btnPreview.setText('Preview (No More Attempts)');
							btnPreview.disable();
							//return;
						}
						// here we can read the records id to use in posting answers
						// add completion time minutes to initial programStarted time
						var endTime = new Date(new Date(me.currentPersonProgram.programStarted).getTime() +
											   me.programData.completionTime * 60000); // completion time in database is in minutes
						var remainingMS = endTime.getTime() - new Date().getTime();
						if(remainingMS > 0 && (me.currentPersonProgram.programStatusId == App.ProgramStatuses["In Progress"] ||
											   me.currentPersonProgram.programStatusId == App.ProgramStatuses.Repeat)){
							btnPreview.addCls('active-program');
							btnPreview.setText('Preview (Resume)');

							me.startPreviewTimer(); // start timer so active-program style gets automatically removed on timeout

						}



					}
					me.serverSync(syncAnswersCallback);
				}
			});
		}else{
			// set localstorage data to tree store
			localStorageData = localStorageData[me.programId];

			var slidesDictToArray = [];
			for(var key in localStorageData.slides){
				slidesDictToArray.push(localStorageData.slides[key]);
			}
			treeStoreSlides.getRootNode().appendChild(slidesDictToArray);

			//treeStoreSlides.setData(localStorageData.slides); // dont use set data
			//treeStoreSlides.getRootNode().appendChild(localStorageData.slides); // also dont use append child with dict but with array

			questionsStoreSlides.setData(localStorageData.questions);
			personAnswersStore.setData(localStorageData.answers);
			if(localStorageData.pageSetup){
				me._pageSetup = localStorageData.pageSetup;
			}

			// set initial data
			me.setInitialSlide();

			me.saveState();


		}


		// Update the online status icon based on connectivity
		window.addEventListener('online',  me.connectionChange);
		window.addEventListener('offline', me.connectionChange);


		refs.panelContent.removeAll();
		refs.toolbarPreview.hide();



	},

	newSection: function() {
		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides'),
			now = new Date(),
			parentNode = /*refs.treeSlides.getSelection()[0] ||*/ store.getRoot(),
			data = {
				id: createGUID(),
				programId: me.programId,
				title: 'New Section',
				content: null,
				expanded: false,
				children: [],
				categoryId : App.ProgramPageCategoriesEnum.Chapter,
				scoreMethod: 'A',
				sequence: 1234,
				lastChanged: now,
				created: now
			};

		slide = parentNode.appendChild(data);
		refs.treeSlides.setSelection(slide);
		//save state needs to be after set selection
		me.saveState();

	},

	newSlide: function() {
		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides'),
		    parentNode = me.getCurrentSlide() || store.getRoot(),
		    slide,
			now = new Date();
		    data = {
		        id: createGUID(),
		        programId: me.programId,
		        sequence: me.getNumSlides(), // todo - this sequence might not be correct to write in database
		        title: 'New Page ' + (me.getNumSlides() + 1),
		        content: null,
		        expanded: true,
		        leaf: true,
		        isSlide : true,
		        categoryId : App.ProgramPageCategoriesEnum.Page,
		        scoreMethod: 'A',
				lastChanged: now,
				created: now

		    };

		// check if we are adding to chapter - if we are - expand it - this may not be needed for sections because they are only added to root
		if(parentNode.data.categoryId == App.ProgramPageCategoriesEnum.Chapter){
			parentNode.data.expanded=true; // expand this node that we are going to paste this new section in
		}

		if(parentNode.isLeaf()) {
		    parentNode = parentNode.parentNode;
		}

		slide = parentNode.appendChild(data);
		me.saveState();
		refs.treeSlides.setSelection(slide);

	},

	deleteSlide: function(slide) {
		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides'),
			deleteSlideWithContent= function(slide, treeStoreSlides, questionsStore) {
				// first decend down the tree to leaf
				if(slide.childNodes && slide.childNodes.length > 0){
					for(var i = 0; i < slide.childNodes.length; i++){
						deleteSlideWithContent(slide.childNodes[i], treeStoreSlides, questionsStore);
					}
				}
				// then delete my data and delete me
				// go through its components, check if its a question, then delete that question
				var components = (Ext.decode(slide.get('content') || '{}').components);
				if(components && Object.keys(components).length > 0){
					for (var key in components){
						var cmp = components[key];

						var cmpType = cmp.type;
						if (cmpType == me.cmpTypes.SELECTION || cmpType == "Single selection" || cmpType == "Multi selection") {
							// update store of that question component
							var rec = questionsStore.findRecord('id', cmp.id);
							questionsStore.remove(rec);

						}
						// remove possible answers for this question from store
						var personAnswers = me.getStore('PersonAnswers');
						var answerRecord = personAnswers.findRecord('questionId', cmp.id);
						if(answerRecord){
							personAnswers.remove(answerRecord);
							personAnswers.sync();
						}
					}

				}
				// remove this slide from tree store
				slide.parentNode.removeChild(slide);

			},

			deleteWrapup = function(slide){
				var treeStoreSlides = me.getStore('TreeStoreSlides'),
					questionsStore = me.getStore('QuestionsStoreSlides');
				// delete this slide with its subtree and conten of each slide in this tree
				deleteSlideWithContent(slide, treeStoreSlides, questionsStore);

				// set localstorage and sync with server if online
				me.saveState();
				me.clearSlidePanel();
				me.nextSlide();
			};

		slide = slide || me.getCurrentSlide();

		if(slide) {
		    var components = (Ext.decode(slide.get('content') || '{}').components),
		        childNodes = slide.childNodes; // child nodes are relevant if this section has any subpages

		    if((components && Object.keys(components).length > 0) || (childNodes && childNodes.length > 0)) {
		        Ext.Msg.confirm( 'Delete slide', 'Are you sure?' +
		                        ((childNodes && childNodes.length > 0)?
		                         " You will delete whole subtree!": ""), function(btn) {
		            if(btn == 'yes') {
						deleteWrapup(slide);
		            }
		        });
		    }
		    else {
				deleteWrapup(slide);
		    }
		}


	},

	getCurrentSlide: function() {
		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides'),currentSlideIdx = store.indexOf(me.currentSlide);


		me.currentSlide = refs.treeSlides.getSelection()[0] || store.getAt(currentSlideIdx) || store.first();

		return me.currentSlide;
	},

	nextSlide: function(slidesOnly = true) {
		//slidesOnly -> variable to recursively descend to first slide - if its set to false, we also visit sections
		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides'),
		    slide = me.getCurrentSlide(),
		    nextSlideIdx = store.indexOf(slide) + 1,
		    nextSlide = store.getAt(nextSlideIdx);

		if(nextSlide) {
		    refs.treeSlides.setSelection(nextSlide);
		    if (nextSlide.data.leaf === false){
		        me.nextSlide(slidesOnly);
		        if(slidesOnly){
		            // recursively iterate to leaf slide through section
		            if (this.getNumSlides() === 0){
		                //cannot switch recursively to next slide", "no slides exist
		                return;
		            }
		            if (me.getCurrentSlide().data.leaf === false){
		                me.prevSlide(slidesOnly);
		            }
		        }
		    }
		}

	},

	prevSlide: function(slidesOnly = true) {
		// slidesOnly -> variable to recursively ascend to first remaining slide - if its set to false, we also visit sections
		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides'),
		    slide = me.getCurrentSlide(),
		    prevSlideIdx = store.indexOf(slide) - 1,
		    prevSlide = store.getAt(prevSlideIdx);


		if(prevSlide) {
		    refs.treeSlides.setSelection(prevSlide);
		    if (prevSlide.data.leaf === false){

		        me.prevSlide(slidesOnly);

		        if(slidesOnly){
		            // recursively iterate to leaf slide through section
		            if (this.getNumSlides() === 0){
		                //cannot switch recursively to prev slide", "no slides exist
		                return;
		            }
		            if (me.getCurrentSlide().data.leaf === false){
		                me.nextSlide(slidesOnly);
		            }
		        }
		    }
		}
	},

	setBackground: function(src, save = true) {
		var me = this,
		    refs = me.getReferences();

		me._pageSetup.background = src;

		if(src) {
		    Ext.getCmp('panelContent').setStyle('background', 'url(' + src + ')');
		}
		else {
		    Ext.getCmp('panelContent').setStyle('background', null);
		}
		if(save){ // if we want to restore background we dont want to save it again
			me.saveState();
		}


	},

	togglePreview: function(preview, yesCallback) {
		// calls show preview or displays dialog option when closing preview - to directly close preview without dialog - call me.closePreview()

		var me = this,
		    refs = me.getReferences();

		if(preview){
		    me.showPreview();

		}else{
		    Ext.Msg.confirm( 'Close preview', 'Are you sure?' + (navigator.onLine? '': ' Warning - Answers will not be submitted until you reconnect!'), function(btn) { // show confirm dialog
		        if(btn == 'yes') {
		            me.closePreview();
					if(yesCallback){ yesCallback(); }
		        } // else do nothing
		    });
		}
	},

	getFreePosition: function() {
		var me = this,
		    refs = me.getReferences(),
		    snap = me._pageSetup.snap,
		    pos = {
		        x: snap * 2,
		        y: snap * 2,
		        width: me.round(refs.panelContent.el.getWidth() - 2 * snap * 2),
		        height: snap * 2
		    };

		Ext.each(refs.panelContent.el.query('.html-component'), function(component) {
		    pos.y = me.round(Math.max(pos.y, component.y + component.height + snap));
		});

		return pos;
	},

	getSlideComponents: function() {
		return this.getReferences().panelContent.el.query('.html-component');
	},

	getCurrentState: function() {
		var me = this,
		    refs = me.getReferences(),
		    slides = Ext.clone(Ext.pluck(refs.treeSlides.store.getRange(), 'data')).map(function(node) {
		        return cleanTreeNodeData(node);
		    });
		     // make dict where key is its id
		    var slidesDict = {};
		    for (var i = 0; i < slides.length; i++){
		        slidesDict[slides[i].id] = slides[i];

		    }
		    questions = Ext.clone(Ext.pluck(me.getStore('QuestionsStoreSlides').getRange(), 'data')).map(function(node) {
		        //return cleanTreeNodeData(node);
		        return node;
		    });
		    var questionsDict = {};
		    for (var i = 0; i < questions.length; i++){
		        questionsDict[questions[i].id] = questions[i];
		    }

		    answers = Ext.clone(Ext.pluck(me.getStore('PersonAnswers').getRange(), 'data')).map(function(node) {
		        //return cleanTreeNodeData(node);
		        return node;
		    });
		    var answersDict = {};
		    for (var i = 0; i < answers.length; i++){
		        answersDict[answers[i].questionId] = answers[i];
		    }

		data = {
		        slides: slidesDict,
		        pageSetup: me._pageSetup,
		        questions: questionsDict,
				answers: answersDict
		    };
		return data;
	},

	loadSlideState: function(slide) {
		var me = this,
		    refs = me.getReferences(),
		    parentEl = refs.panelContent.el.down('#html-slide');

		me.clearSlidePanel();

		if(slide) {
		    var content = Ext.decode(slide.get('content') || '{}');
		    for (var key in content.components){
		        var component = content.components[key];
				if(!component.id){
					// if component itself doesnt have id, we append it - this is needed for questions when they are created offline
					component.id = key;
				}
		        this.insertComponent(component);
		    }
		}
	},

	clearSlidePanel: function() {
		var me = this,
		    refs = me.getReferences(),
		    parentEl = refs.panelContent.el.down('#html-slide');

		// remove components from panel
		Ext.each(parentEl.query('.html-component'), function(component) {
		    parentEl.removeChild(component);
		}, this);

		// deselect all components
		if(me._selectedComponents){
			for(var i = 0; i < me._selectedComponents.length; i++){
				me._selectedComponents[i].fireEvent('deselect');
			}
		}
		me._selectedComponents = [];
		me.allComponents = []; // clear old components from prev slide
		// hide tools
		me.hideComponentTools();
	},

	addComponentListeners: function(item) {
		var me = this,
		    item = Ext.get(item);

		item.on('deselect', function(e,t){
		    item.removeCls('selected');
		    /*if(item._resizer){
		              item._resizer.destroy();
		        item._resizer = null;
		    }*/
		});
		item.on('select', function(e,t){
		    me._selectedComponents.push(item);
		    item.addCls('selected');
		    /*if(!item._resizer){
		        me.createResizer(item);

		    }*/
		});
		item.on('click', function(e, t) {
		    if(e.stopPropagation){ e.stopPropagation(); }
		    if(me.previewing || (!e.ctrlKey && !e.shiftKey )){ // if we are previewing or we didnt hold multiselect buttons
		        for(var i = 0; i < me._selectedComponents.length; i++){
		            var cmp = me._selectedComponents[i];
		            cmp.fireEvent('deselect');
		        }
		        me._selectedComponents = []; // clear array
		        me.hideComponentTools();
		    }
		    else{
		        if (e.ctrlKey || e.shiftKey) {
		            // check if this component is already in array of selected components - in this case - remove it
		            var index = me._selectedComponents.indexOf(item);
		            if (index > -1) {
		                var removedItem = me._selectedComponents.splice(index, 1)[0];
		                item.fireEvent('deselect');
		                if(!me._selectedComponents.length){// disable tools if there are no more components selected

		                    me.hideComponentTools();
		                }
		                // no items selected anymore - return
		                return;
		            }
		        }
		    }
		    if(!me.previewing){
		        item.fireEvent('select');
		        me.showComponentTools(item);
		    }
		    if(me.previewing){
		        // previewing

				if(!t){
					console.warn("Error occured - maybe with sliders, drag and drop etc");
				}

		        // Handle checkboxes and radio buttons
		        var SELECTED_VALUE = t.getAttribute('idx'); // idx have checboxes and radio buttons
		        if (SELECTED_VALUE){
		            // getting array from html collection
					var answers = Array.from(item.dom.children[0].children), // to change dom style
						questionId = item.el._opts.id,
						prevAnswer = me.getStore('PersonAnswers').findRecord('questionId', questionId),
						answers_js = prevAnswer? Ext.decode(prevAnswer.data.answer): {};

		            answers.shift(); // remove first text item (text) - all other are radio / check buttons

					var type = answers[0].getAttribute('type');
		            switch(type) {
		                case 'radio':
		                    for (var i = 0, len = answers.length; i < len; i++) {
		                        answers[i].classList.remove('selected');
		                        answers_js[i] = false;
		                    }
		                    answers[SELECTED_VALUE].classList.add('selected');
		                    answers_js[SELECTED_VALUE] = true;
		                    break;
		                case 'check':
		                    // toggle the selected value
		                    answers[SELECTED_VALUE].classList.toggle("selected");
		                    answers_js[SELECTED_VALUE] = !answers_js[SELECTED_VALUE];
							if(answers_js[SELECTED_VALUE] === undefined){
								answers_js[SELECTED_VALUE] = true;
							}
		                    break;
		                default:

		                    console.warn("Caller - addComponentListeners", "Unsupported component type" ,type);
							return;
		            }
					var now = new Date();
					var recordAnswers = {
						questionId: item._opts.id,
						id: createGUID(),
						created: now,
						lastChanged: now,
						personProgramId: me.currentPersonProgram.personTrainingProgramId,
						answer:{},
						score: 0 // TEMP - TODO CHANGE RECORD AFTER EVALUATING
					};

		            // create record
		            for (var key in answers_js) {
		                recordAnswers.answer[key] = answers_js[key];
		            }
		            recordAnswers.answer = Ext.encode(recordAnswers.answer);

					// find in store if record for this question already exists - if it does overwrite it
					var personAnswersStore = me.getStore('PersonAnswers');
					var answerExists = personAnswersStore.findRecord('questionId', recordAnswers.questionId);


					if(answerExists){
						// remove all answers that may be duplicates and add new one
						var tmpNewArray = [];

						for(var j = 0; j < personAnswersStore.data.items.length; j++){
							var _tempAnswer = personAnswersStore.data.items[j];
							if(_tempAnswer.data.questionId == recordAnswers.questionId){
								tmpNewArray.push(_tempAnswer);
							}
						}personAnswersStore.remove(tmpNewArray); // remove all answers that have this question id
					}

					var answerRec = personAnswersStore.add(recordAnswers)[0];
					answerRec.phantom = true;

					// save this to localstorage - post answers only on quiz end, restore answers in localstorage and in store on page reload
					me.saveState(true); // parameter true is dontSync - store this only in localstorage and dont push on server - yet

		        }
		    }
		});
		item.on('dblclick', function(e, t) {
		    if(!me.previewing){
		        me.editComponent(item);
		    }
		});

		item.on('_edit', function(e, t) {
		    if(!me.previewing){
		        me.editComponent(item);
		    }
		});

		item.on('_duplicate', function(e, t) {
		    if(!me.previewing){
		        me.duplicateComponent(item);
		    }
		});

		item.on('_delete', function(e, t) {
		    if(!me.previewing){
		        me.deleteComponent(item, true); // sync is true
		        me.hideComponentTools(item);

		    }
		});

	},

	showComponentTools: function(component) {
		var me = this;

		if(!me._componentTools) {
		    me._componentTools = me.getView().add({ xtype: 'edittools' });
		}
		me._componentTools.getController().show({ components: me._selectedComponents });
	},

	hideComponentTools: function(component) {
		var me = this;

		if(!me._componentTools) {
		    me._componentTools = me.getView().add({ xtype: 'edittools' });
		}
		me._componentTools.close();

	},

	insertComponent: function(opts, callback) {
		opts = Ext.applyIf(opts || {}, {
		    type: null,
		    height: null,
		    width: null,
		    x: null,
		    y: null,
		    html: '',
		    options: [],
		    multi: false,
		    src: '',
		    cls: null,
		    style: null
		});

		if (!opts.type) {
		    console.warn('Error', 'No component type');
		    return;
		}


		if (opts.cls && typeof opts.cls == "string") {
		    opts.cls = [opts.cls];
		}

		var me = this,
		    refs = me.getReferences(),
		    pos = me.getFreePosition(),
		    snap = me._pageSetup.snap,
		    parentEl = refs.panelContent.el.down('#html-slide'),
		    cmp = document.createElement('div'),
		    currentSlide = me.getCurrentSlide();

		if(!me.currentSlide){
			me.newSlide();
		}

		// set size
		// if(opts.type == 'image' && opts.src) {
		//     // determine image size
		//     var img = new Image();

		//     img.onload = function() {
		//         cmp.width = me.round(isNull(opts.width, img.width));
		//         cmp.height = me.round(isNull(opts.height, img.height));
		//         cmp.style.width = cmp.width + 'px';
		//         cmp.style.height = cmp.height + 'px';
		//     };
		//     img.src = opts.src;

		//     // show image as background
		//      cmp.style.backgroundImage = 'url(' + opts.src + ')';
		// }
		// else {

		if(opts.x === undefined || opts.x === null){
			opts.x = pos.x;
		}
		if(opts.y === undefined || opts.y === null){
			opts.y = pos.y;
		}
		opts.x = cmp.x = pos.x = me.round(opts.x);
		opts.y = cmp.y = pos.y = me.round(opts.y);
		opts.width = cmp.width = pos.width = me.ceil(opts.width || pos.width);
		opts.height = cmp.height = pos.height = me.ceil(opts.height || pos.height);

		cmp.style.width = cmp.width + 'px';
		cmp.style.height = cmp.height + 'px';
		// }

		// set classes
		cmp.classList.add('html-component');

		// set position
		cmp.x = opts.x = isNull(opts.x, pos.x);
		cmp.y = opts.y = isNull(opts.y, pos.y);
		cmp.style.left = cmp.x + 'px';
		cmp.style.top = cmp.y + 'px';

		// set content
		var content = document.createElement('div');
		var html = opts.html;

		// todo - simplify this if - but from server opts.type is returned as Single or Multi selection because it doesnt have special attribute
		if ((opts.type == me.cmpTypes.SELECTION && opts.options) || opts.type == 'Single selection' ||opts.type == "Multi selection") {
		    cmp.style.height = ''; // remove height property from component so it will default to 100%
		    opts.cls = [me.cmpTypes.SELECTION];


		    // insert selection has been called with specific id, so we must retrieve it from database end spawn it here
		    /*var storageData = Ext.decode(localStorage.getItem('mxp_elearning'))[me.programId],
		        questions = storageData.questions,
		        question = questions[opts.id];
			*/
			 var question = me.getStore('QuestionsStoreSlides').findRecord('id',opts.id);
		    if(!question){
		        console.warn("No questions exist for this program. Returning...");
		        return;
		    }


		    var record = question.data;
		    opts.type = record.fieldType;
		    // TODO - FIx this line below because its inefficient -
		    opts.options = Ext.decode(record.lookups);
		    html = record.question;
		    // todo we dont store in database if question is multi answer or not so in editSelection this text is rendered
		    opts.multi = opts.type == "Multi selection"; // checks against string if its multi selection
		    opts.html = html;
		    opts.cls = [me.cmpTypes.SELECTION];
		    opts.id = opts.id;

		    html = '<div class="text">' +'<h3 style="text-align:center;">'+ html + '</h3>' + '</div>';

		    Ext.each(opts.options, function (option, index, allItems) {
		        var cls = ['option', (opts.multi ? 'check' : 'radio')];

		        if (option.correct) {
		            cls.push('correct');
				}

				// find answers in answers store - newly created components dont have answers yet so 'selected' wont be applied
				var answerRecord = me.getStore('PersonAnswers').findRecord('questionId', opts.id); // find record by questionGuid
				if(answerRecord){
					if(Ext.decode(answerRecord.data.answer)[index] === true){
						cls.push('selected');
					}
				}

		        // added two custom attributes idx which is index of element (starting with 0) and type which can contain chech or radio
		        html += '<div class="' + cls.join(' ') + '" idx=' + index + ' type=' + (opts.multi ? 'check' : 'radio') + ' style="width:fit-content;">' + option.text + '</div>';
		    });
		}

		if (opts.type == me.cmpTypes.IMAGE && opts.src) {
		    if(navigator.onLine){
		        content.style.backgroundImage = 'url(' + opts.src + ')';
		    }else{
		        content.style.backgroundColor = 'powderblue';
		        html = 'Image cannot be loaded - go online to view photo';
		    }
		}

		// adding classes to surrounding div element of component
		content.classList.add('html-content');
		Ext.each(opts.cls, function (cls) {
		    content.classList.add(cls);
		});

		content.innerHTML = html;
		content = cmp.appendChild(content);
		cmp = parentEl.dom.appendChild(cmp);

		cmp.style.height = me.ceil(cmp.clientHeight)+'px'; // again make sure that components are snapping to corrent grid

		// check if content is overflowing the panel - reset it back to bottom of panel
		if(pos.y +  me.round(cmp.clientHeight) > refs.panelContent.el.getHeight()){
		    opts.y = cmp.y = pos.y =  me.round(refs.panelContent.el.getHeight() -  cmp.clientHeight);
		    cmp.style.top = opts.y+'px';
		}

		cmp._opts = opts;
		cmp.type = opts.type;

		extCmp = Ext.get(cmp);
		extCmp._opts = opts;
		extCmp.type = opts.type;


		if (!me.previewing) {
		    cmp._dragger = new Ext.drag.Source({
		        element: extCmp,
		        constrain: {
		            element: parentEl,
		            snap: {
		                x: snap,
		                y: snap
		            }
		        },
		        listeners: {
		            beforedragstart: function (component, info, event, eOpts) {

						if(!me._selectedComponents.length){
							// if no componets are selected - fire click for this component
							component.config.element.fireEvent('click');
						}
						if (info.eventTarget.classList.contains('x-resizable-handle')) {
							return false;
						}

		            },
		            dragcancel: function (component, info, event, eOpts) {
		                var prevWrapper = document.getElementById("lineWrapper");
		                if(prevWrapper){
		                    prevWrapper.outerHTML = ""; // remove old wrapper
		                }
		            },
		            dragend: function (component, info, event, eOpts) {
		                var prevWrapper = document.getElementById("lineWrapper");
		                if(prevWrapper){
							prevWrapper.outerHTML = ""; // remove old wrapper
						}
						var currentSlide = me.getCurrentSlide();

						// set new info to this new altered component

						var alteredContent = Ext.decode(currentSlide.data.content);
						for(var i = 0; i < me._selectedComponents.length; i++){
							//var id = component.config.element._opts.id;
							var id = me._selectedComponents[i]._opts.id;
							for (var key in alteredContent.components){
								if(alteredContent.components[key].id == id){
									alteredContent.components[key].x = component._element.dom.offsetLeft;
									alteredContent.components[key].y = component._element.dom.offsetTop;
								}
							}
						}
		                // change store and sync
		                var storeItems = me.getStore('TreeStoreSlides').data.items;

						/*var slide = me.getStore('TreeStoreSlides').findRecord('id', currentSlide.id);
						slide.data.content = Ext.encode(alteredContent);
						slide.data.lastChanged = new Date();
						slide.phantom = true;
						*/
						for(var i = 0; i < storeItems.length; i++){
							if(storeItems[i].id == currentSlide.id){
								storeItems[i].data.content = Ext.encode(alteredContent);
								storeItems[i].data.lastChanged = new Date();
								storeItems[i].phantom = true;
								break;
							}
						}
						me.saveState();
						me._dragged = true;
		            },
		            dragmove: function (component, info, event, eOpts) {
						var difx = component._element.dom.offsetLeft - component.config.element._opts.x,
							dify = component._element.dom.offsetTop - component.config.element._opts.y;

						for(var i = 0; i < me._selectedComponents.length; i++){
		                    var selectedCmp = me._selectedComponents[i];
		                    selectedCmp._opts.x += difx;
		                    selectedCmp._opts.y += dify;

							selectedCmp.dom.offsetLeft = selectedCmp._opts.x;
							selectedCmp.dom.offsetTop = selectedCmp._opts.y;

							selectedCmp.dom.style.left = selectedCmp._opts.x+'px';
							selectedCmp.dom.style.top = selectedCmp._opts.y+'px';

		                }
						me.drawHelperLines(component);
						me.showComponentTools(component);

		            },
		            dragstart: function (component, info, event, eOpts) {
		                component.config.element._opts.x = component._element.dom.offsetLeft;
		                component.config.element._opts.y = component._element.dom.offsetTop;
		                me.drawHelperLines(component);

		            }
		        }
		    });

		    me.createResizer(cmp);

		}

		me.addComponentListeners(cmp);
		me.allComponents.push(extCmp); // append this newly created component to all components, so we can select it later

		if(callback){ callback(); }

		return extCmp;
	},

	editComponent: function(component) {
		var me = this,
		    refs = me.getReferences();

		component = component || me._selectedComponent;
		if (component) {
		    if ((component.type == me.cmpTypes.IMAGE) || (component.type == me.cmpTypes.VIDEO) || (component.type == me.cmpTypes.AUDIO) ){
		        Ext.toast("Cannot edit image, video or audio.");
		        return;
		    }

		    if (component.type == me.cmpTypes.SELECTION || component.type == "Single selection" || component.type == "Multi selection") {
		        me.editSelection(component);
		    }

		    else {
		        var wnd = me.getView().add({xtype: 'texteditor'});

		        wnd.getController().show({
		            value: component.el.down('.html-content').dom.innerHTML,
		            callback: function (value) {
		                component.el.down('.html-content').dom.innerHTML = value;
		                component._opts.html = value;
		                me.saveState();
		            },
		            scope: me
		        });
		    }
		}
	},

	duplicateComponent: function(component) {
		var me = this,
		    component = Ext.clone(component);
		var opts = Ext.clone(component._opts);

		delete opts.x;
		delete opts.y;

		var cmpType = component._opts.type;
		if (cmpType == me.cmpTypes.SELECTION || cmpType == "Single selection" || cmpType == "Multi selection") {
		    opts.text = component._opts.html;
		    opts.answers = component._opts.options;
		    me.createSelection(opts);
		}

		else{
		    // for all other components - call ordinary insert component

		    // rename its id
		    opts.id = createGUID();
		    var cmp = this.insertComponent(opts);

		}
		me.saveState();
	},

	deleteComponent: function(component, sync) {
		var me = this,
			refs = this.getReferences(),
			questionStore = me.getStore('QuestionsStoreSlides'),
			treeStoreSlides = me.getStore('TreeStoreSlides');

		if(component) {

			if(sync){ // we might not always want to sync, but only delete this component in order to redraw it



				// remove component from slide content and set its record.phantom to true, for it to later update
				var id = component.el._opts.id;
				var currentSlide = me.getCurrentSlide();


				var rec = questionStore.findRecord('id', id);
				questionStore.remove(rec);

				// UPDATING SLIDE

				// set new info to this new altered component
				var removedComponentsArray = {};
				var slideContent = Ext.decode(currentSlide.data.content);
				for (var key in slideContent.components){
					if(slideContent.components[key].id != id){
						// add every other component than the one we are deleting
						removedComponentsArray[key] = slideContent.components[key];
					}
				}
				var componentsDict = {'components': removedComponentsArray};

				// change slide store and sync
				var store = me.getStore('TreeStoreSlides');
				var rec = store.findRecord('id', currentSlide.id);
				// update record
				rec.data.content = Ext.encode(componentsDict);
				rec.data.changed = 'Y';
				rec.data.lastChanged = new Date();
				rec.phantom = true;

				// remove possible answers for this question from store
				var personAnswers = me.getStore('PersonAnswers');
				var answerRecord = personAnswers.findRecord('questionId', id);
				if(answerRecord){
					personAnswers.remove(answerRecord);
					personAnswers.sync();
				}




			}
			if(!me.allComponents){
				console.warn("Error - For some reason this component was not in >allComponents< array.");
				me.allComponents.remove(component);
			}



			component.destroy();
			component = null;

			if(sync){
				// save state
				me.saveState(); //save changes to localstorage and sync with server if online
			}
		}
	},

	insertTitle: function(value) {
		var me = this,
		    cmp = me.insertComponent({

		        id: createGUID(),
		        type: me.cmpTypes.TITLE,
		        cls: 'title',
		        html: value || 'Title',
		        height: 50

		    });



		 me.saveState();

	},

	insertText: function(value) {
		var me = this,
		    cmp = me.insertComponent({
		        id: createGUID(),
		        type: me.cmpTypes.TEXT,
		        cls: 'text',
		        html: value || 'Text',
		        height: 200

		    });
		 me.saveState();

	},

	insertImage: function() {
		var me = this,
		    cmp = me.insertComponent({
		        id: createGUID(),
		        type: me.cmpTypes.IMAGE,
		        cls: 'image',
		        html: '',
		        src: 'resources/images/example.jpg',
		        height: 275,
		    });
		 me.saveState();
	},

	insertSelection: function(opts) {
		this.editSelection(null, opts);

	},

	editSelection: function(component, opts) {
		opts = Ext.applyIf(opts || {}, {
		    multi: false
		});

		var me = this,
		    refs = me.getReferences(),
		    state = component && component._opts,
		    multi = state && state.multi || opts.multi,
		    wnd = me.getView().add({ xtype: 'selectioneditor' });

		wnd.getController().show({
		    text: state && state.html,
		    options: state && state.options,
		    multi: multi,
		    callback: function(text, answers) {
		        var opts = {
		            text: text,
		            answers: answers,
		            multi:multi,
		            component : component
		        };



				me.createSelection(opts);


		    },
		    scope: me
		});
	},

	round: function(value) {
		var snap = this._pageSetup.snap;

		return Math.round(value / snap) * snap;
	},

	ceil: function(value) {
		var snap = this._pageSetup.snap;

		return Math.ceil(value / snap) * snap;
	},

	insertAudio: function() {
		var me = this,
		    cmp = me.insertComponent({
		        id: createGUID(),
		        type: me.cmpTypes.AUDIO,
		        cls: 'audio',
		        html: '<audio controls>  <source src="resources/audio/horse.mp3" type="audio/mpeg">Your browser does not support the audio element.</audio>',
		        src: 'resources/audio/horse.mp3',
		        height: 50,
		    });
		me.saveState();
	},

	insertVideo: function() {
		var me = this,
		    cmp = me.insertComponent({
		        id: createGUID(),
		        type: me.cmpTypes.VIDEO,
		        cls: 'video',
		        html: '<video width="320" height="240" controls>  <source src="resources/videos/mov.mp4" type="video/mp4"> Your browser does not support the video tag.</video>',
		        src: 'resources/videos/mov.mp4',
		        height: 240,
		    });
		me.saveState();
	},

	getNumSlides: function() {
		// Retrieves count of slides (sections don't count)
		var me = this,
		    countSlides = 0,
		    data = Ext.decode(localStorage.getItem('mxp_elearning'))[me.programId];
		if(!data.slides || !Object.keys(data.slides).length){
		    return 0;
		}
		for(var key in data.slides){
		    if(data.slides[key].isSlide ||data.slides[key].categoryId == App.ProgramPageCategoriesEnum.Page){
		        countSlides += 1;
		    }
		}
		return countSlides;
	},

	evaluate: function() {
		// returns [singleSelectionCorrect, singleSelectionQuestions, multipleSelectionScore, multipleSelectionScoreUsingNegative]
		// multipleSelectionScore -> if answer_correct -> answer_score += 1/num_answers
		//							 else: answer_score = (answer_score - 1/num_answers).clamp(0, num_answers)
		//multipleSelectionScoreUsingNegative -> dont clamp incorrectly answered
		Number.prototype.clamp = function (min, max) {
		    return Math.min(Math.max(this, min), max);
		};

		// iterate through slides and questions and check score:
		var me = this,
		    usingNegativeScore = false, // config variable which determines if each answer can have negative return points
		    programScore = {"questions":{}, "totalProgramScore": -1};

		var questions = me.getStore('QuestionsStoreSlides').data.items;
		var answersStore = me.getStore('PersonAnswers');
		for(var i = 0; i < questions.length; i++){

		    var question = questions[i].data;
		    var answerData = answersStore.findRecord('questionId', question.id).data;
		    programScore.questions[question.id] = me.getScore(question, answerData.answer, usingNegativeScore);
			answerData.score = programScore.questions[question.id]; // setting answer score


			print("setting new answer score for this answer",  programScore.questions[question.id] , "to", answerData);
		}


		// suming questions scores to total score
		var totalProgramScore = sumDict(programScore.questions);
		if(totalProgramScore >= me.programData.passScore){
			console.log("%cFinal user score:", "color: green", totalProgramScore);
		}
		else{
			console.log("%cFinal user score:", "color: red", totalProgramScore);
		}




		programScore.totalProgramScore = totalProgramScore;

		return programScore;
	},

	getScore: function(question, answer, usingNegativeScore) {
		if(!answer){
			// user didnt check any options on this question - return
			return 0;
		}
		answer = Ext.decode(answer);

		var answerScore = 0;
		var correctAnswer;
		var usersAnswer = answer;

		var question_answers = question.options || question.lookups; // in datase options are stored in lookups table so we return lookups
		if( typeof question_answers === 'string'){ // todo sometimes its not encoded - fix this
			var _question = Ext.decode(question_answers);

		}else{
			var _question = question_answers;
		}
		var questionNumAnswers = _question.length;

		if (question.multi || question.fieldType == "Multi selection") { // Todo - decide which attribute to use!!
			// make a pre-pass counting num_correct_answers
			var numCorrectAnswers = 0;
			_question.forEach(function (option) {

				if (option.correct) {
					numCorrectAnswers += 1;
				}
			});
			// go through all questions in this form

			for(var i = 0; i < _question.length; i++){
				usersAnswer = answer[i];
				correctAnswer = _question[i].correct;

				if(usersAnswer === undefined){ // if he didnt check any options or this checkbox has never been checked
					usersAnswer = false;
				}


				if (usersAnswer == correctAnswer) {
					if (correctAnswer === true) {
						// if we checked correct answer - add percent of all correct answers to his score
						answerScore += (1 / numCorrectAnswers);
					}
					// no else - we are not rewarding for not checking not-correct answers
				}
				else{
					// we didnt click what is correct

					if (correctAnswer === true) {
						// if we clicked no but answer was yes, punish user by subtracting percent of all correct answers from his score
						answerScore -= (1 / numCorrectAnswers);
					}
					else{
						// if we clicked yes but answer was no, punish user by subtracting only percent of num answers
						answerScore -= (1/ questionNumAnswers);
					}
				}
			}

			// append score of this questionary to totalScore
			if(!usingNegativeScore){
				// clamp between 0 and max
				answerScore = (answerScore).clamp(0, questionNumAnswers);
			}

		} else {
			// evaluate
			for(var i = 0; i < _question.length; i++){
				usersAnswer = answer[i];
				correctAnswer = _question[i].correct;

				if ((correctAnswer === true) && (usersAnswer == correctAnswer)) {
					answerScore = 1;
				}
				else {
					if(usersAnswer == correctAnswer){
						// this is not right answer but we checked right one

						if(usingNegativeScore){
							// returns -1 - is this too much?
							answerScore = -1;
						}
						// else return 0
					}
				}

			}

		}

		return answerScore;
	},

	saveState: function(dontSync) {
		var THUMBNAILS = false,
			me = this,
			refs = me.getReferences(),
			syncIndicator = Ext.getCmp('syncIndicator'),
			content = {
				components: {}
			};

		// first update current slide
		slide = me.getCurrentSlide();
		if(slide) {
			var slideComponents = me.getSlideComponents();
			for (var key in slideComponents){
				var component = slideComponents[key];
				if(component._opts.type == me.cmpTypes.SELECTION){
					// if its question, append only guid of this question to content components
					var _opts = Ext.clone(component._opts);

					var _optsNew = {"type": _opts.type, "id": _opts.id };
					content.components[_opts.id]=_optsNew;
				}else{
					// append whole content
					content.components[component._opts.id] = component._opts;
				}
			}
			//slide.set('lastChanged', new Date()); // set last changed for this slide here
			slide.set('content', Ext.encode(content));
		}

		var data = this.getCurrentState();

		var localStorageData = Ext.decode(localStorage.getItem('mxp_elearning'));
		// init if we are saving content for duplicate program
		if(!localStorageData[me.programId]){
			localStorageData[me.programId] = {};
		}
		for (var key in data) {
			localStorageData[me.programId][key] = data[key];
		}

		// sets current state to localstorage and calls update with server
		localStorage.setItem('mxp_elearning', Ext.encode(localStorageData));

		if(dontSync){
			// for some reason we want to store current state in localstorage but not sync to server
			// this is used for personAnswers where we dont post for every click on answer but just want to save to localstorage
			// so he can return to this quiz if his computer crashes
			me.updateStatusIndicator(false);
			return;
		}
		var storeSlides = me.getStore('TreeStoreSlides'),
			storeQuestions = me.getStore('QuestionsStoreSlides'),
			storePrograms = me.getStore('PersonPrograms');








		if(navigator.onLine){
			// sync all stores
			storeSlides.sync();
			storeQuestions.sync();
			storePrograms.sync();


			// after syncing everything - we can delete current programs' removed entries
			localStorageData = Ext.decode(localStorage.getItem('mxp_elearning'));
			if(localStorageData[me.programId].removed){
				delete localStorageData[me.programId].removed;
			}
			localStorage.setItem('mxp_elearning', Ext.encode(localStorageData));

			me.updateStatusIndicator(true);
		}else{
			me.updateStatusIndicator(false);
		}

		var btnDeleteSlide = Ext.getCmp('btnDeleteSlide'),
			btnPreview = Ext.getCmp('btnPreview');

		btnDeleteSlide.setDisabled(!storeSlides.data.items.length);

		if(!me.programData){
			btnPreview.enable();
			btnPreview.setText('Preview');
		}else{
			if(me.programData.validTo > new Date()){
				btnPreview.setText('Preview (Not Valid Anymore)');
				btnPreview.removeCls('active-program');
				btnPreview.disable();
			}else{
				if(!storeQuestions.data.items.length){
					btnPreview.disable();
					btnPreview.setText('Preview (No Questions)');
				}else{


					if(me.currentPersonProgram && (me.currentPersonProgram.attempt >= me.programData.maxAttemptsTrainingMode + me.programData.maxAttemptsScoreMode)){
						// Cannot attempt any more tries... returning
						btnPreview.setText('Preview (No More Attempts)');
						btnPreview.disable();
					}else{
						btnPreview.enable();
						btnPreview.setText('Preview');

						if(btnPreview.hasCls('active-program')){
							// restore text
							btnPreview.setText('Preview (Resume)');
						}
					}
				}
			}
		}

		if(me.getCurrentSlide()){
			callback =function(url,base64encodedImg){
				print("encoded", base64encodedImg);
			};

			if(THUMBNAILS){
				me.captureSlide(callback);
				me.renderThumbnails();
			}


		}




	},

	setInitialSlide: function() {
		// this function is used to set slide after syncing with server or initially recieving data (from localstorage or server)
		var me = this,
		    refs = me.getReferences(),
			currentSlide = me.getCurrentSlide();


		me.setBackground(me._pageSetup.background, false); // dont save when restoring background
		refs.panelContent.setWidth(me._pageSetup.width);
		refs.panelContent.setHeight(me._pageSetup.height);


		if(currentSlide){
			refs.treeSlides.setSelection(null);
		    refs.treeSlides.setSelection(currentSlide);

		}


	},

	closePreview: function(force = false) {
		var me = this,
			 btnPreview = Ext.getCmp('btnPreview');

		me.previewing = false; // setting current previewing state



		if(navigator.onLine){
			me.validatePersonProgram();

			// reset button to default
			btnPreview.removeCls('active-program');
			btnPreview.setText('Preview');

			clearInterval(me.previewTimer);

		}
		else{
			Ext.toast("Cannot validate program. Go online to submit answers.");



			// write unsynced: true to localstorage to sync person program on online change
			var localStorageData = Ext.decode(localStorage.getItem('mxp_elearning'));
			localStorageData[me.programId].personProgram = {unsynced: true};
			localStorage.setItem('mxp_elearning', Ext.encode(localStorageData));




			btnPreview.addCls('active-program');
			btnPreview.setText('Preview (Resume)');


		}

		if(force){
			// timer may force close
			btnPreview.removeCls('active-program');
			btnPreview.setText('Preview');
			clearInterval(me.previewTimer);

		}

		me.togglePreviewFrame(false);

	},

	showPreview: function() {



		var me = this,
			refs = me.getReferences(),
			personProgramsStore = me.getStore('PersonPrograms'),
			personAnswersStore = me.getStore('PersonAnswers');


		var numQuestions = me.getNumQuestions();

		if(this.getNumSlides() === 0){
			Ext.toast("Unable to preview program with no pages.");
			return;
		}
		if(numQuestions === 0){
			Ext.toast("Unable to start preview with no questions.");
			return;
		}
		if(me.programData.validTo < new Date()){
			Ext.toast("Program is not valid anymore!");
			return;
		}

		if(!navigator.onLine){
			Ext.toast("Cannot start program in offline!");
			return;
		}

		// Create PersonProgram or update it here
		personProgramsStore.load({
			params:{
				personId: App.personId,
				programId: me.programId
			},
			callback:function(record){
				if(!record || record.length === 0){
					//recieved no record back - maybe here we know that this persons program doesnt exist yet so add it

					Ext.Msg.confirm( 'Start preview', 'Start your first preview?' , function(btn) { // show confirm dialog
						if(btn == 'yes') {
							me.currentPersonProgram = { // store whole record
								personProgramGuid: createGUID(),
								personId: App.personId,
								programId: me.programId,
								programStatusId: App.ProgramStatuses["In Progress"],
								createdById: App.personId, // TODO - same person is also creating this program? can this be different?
								created: new Date(),
								programStarted: new Date(),
								lastChanged: new Date(),
								changed: 'N',
								attempt: 0,
							};

							// record doesnt exist yet - add new
							var rec = personProgramsStore.add(me.currentPersonProgram)[0];
							rec.phantom = true;

							personProgramsStore.sync();
							me.switchToPreviewing(); // display new quiz
						}
					});
				}
				else{
					me.currentPersonProgram = record[0].data;
					if(me.currentPersonProgram.attempt >= me.programData.maxAttemptsTrainingMode + me.programData.maxAttemptsScoreMode){
						Ext.toast("No more tries avaliable.");
						return;
					}

					// here we can read the records id to use in posting answers
					// add completion time minutes to initial programStarted time
					var endTime = new Date(new Date(me.currentPersonProgram.programStarted).getTime() +
										   me.programData.completionTime * 60000); // completion time in database is in minutes
					var remainingMS = endTime.getTime() - new Date().getTime();

					if(remainingMS > 0 && (me.currentPersonProgram.programStatusId == App.ProgramStatuses["In Progress"] ||
										   me.currentPersonProgram.programStatusId == App.ProgramStatuses.Repeat)){

						me.switchToPreviewing(false);  // display still active try of this quiz
					}else{

						//we show dialog that by proceeding we will use another try
						Ext.Msg.confirm( 'Start preview', 'Start new program preview?' , function(btn) { // show confirm dialog
							if(btn == 'yes') {
								var existingRecord = personProgramsStore.findRecord('personTrainingProgramId', me.currentPersonProgram.personTrainingProgramId);

								// create new current person program
								me.currentPersonProgram = {
									personProgramGuid: me.currentPersonProgram.personTrainingProgramId,
									attempt: me.currentPersonProgram.attempt + 1, // increase attempt counter
									lastChanged: new Date(),
									changed : 'Y',
									programStatusId: App.ProgramStatuses.Repeat,
									programStarted: new Date(),

								};
								// program already exists - so update it
								existingRecord.data = me.currentPersonProgram;
								existingRecord.phantom = true;

								personProgramsStore.sync();
								me.switchToPreviewing(); // display new try of this quiz
							}
						});
					}
				}
			}
		});
	},

	togglePreviewFrame: function(preview) {
		// Display content
		var me = this,
		    refs = me.getReferences();
		//refs.panelMenu.setVisible(!preview); // commented so navigation tree is visible even when solving quiz
		refs.toolbarEdit.setVisible(!preview);
		refs.toolbarPreview.setVisible(!!preview);
		refs.panelContent[preview ? 'removeCls' : 'addCls']('edit');
		refs.panelContent[preview ? 'addCls' : 'removeCls']('preview');

		refs.panelSlide.setMargin(preview ? '10' : '10 10 10 0');

		// retarget this slide - this redraws current slide without dragger and sizer
		var currentSlide = me.getCurrentSlide();
		refs.treeSlides.setSelection(null);
		refs.treeSlides.setSelection(currentSlide);
	},

	switchToPreviewing: function(clean = true) {
		var me = this,
		    refs = me.getReferences();

		me.startPreviewTimer();

		me.previewing = true;
		if(clean){
			// when we are continuing previewing, we dont want to remove previous answers
			me.getStore('PersonAnswers').loadData([],false); // remove previous answers
		}

		// show slide state

		var firstSlide = refs.treeSlides.store.getAt(0);
		refs.treeSlides.setSelection(firstSlide);
		// on panel toggle - drop down the sections to first actual slide
		if (firstSlide.data.leaf === false){
		    me.nextSlide();
		}
		me.togglePreviewFrame(true);
	},

	drawHelperLines: function(component) {
		var me = this,
			_component = component.config.element? component.config.element: component.el,
			refs = me.getReferences(),
			panelWidth = refs.panelContent.el.getWidth(),
			panelHeight = refs.panelContent.el.getHeight(),
			componentWidth =_component._opts.width,
			componentMiddleWidth = componentWidth / 2,
			componentHeight =_component._opts.height,
			componentMiddleHeight = componentHeight / 2,
			x = _component._opts.x,
			y = _component._opts.y;

		var svgContent = `<svg height="` + panelHeight+`" width="` + panelWidth + `">`;
		// get all components and compare if some line is intersecting its bounding box or middle
		var currentSlide = me.getCurrentSlide();
		var slideComponents = Ext.decode(currentSlide.data.content);
		for (var key in slideComponents.components){
			if(key != _component._opts.id){

				var neighbourCmp = slideComponents.components[key];

				//Todo - multiple lines will draw over the same spot if multiple components have for example same x
				if(neighbourCmp.x == x){
					svgContent+= `<line x1=" ` +x +`" y1="0" x2="` +x +`" y2="`+panelHeight+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>`;
				}
				if(neighbourCmp.x + neighbourCmp.width /2 == x + componentMiddleWidth){
					svgContent+= `<line x1=" ` +(x + componentMiddleWidth) +`" y1="0" x2="` +(x + componentMiddleWidth) +`" y2="`+panelHeight+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>`;

				}
				if(neighbourCmp.x + neighbourCmp.width == x + componentWidth){
					svgContent += `<line x1=" ` +(x + componentWidth) +`" y1="0" x2="` +(x + componentWidth) +`" y2="`+panelHeight+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>`;
				}


				if(neighbourCmp.y == y){
					svgContent += `<line y1=" ` +y +`" x1="0" y2="` +y +`" x2="`+panelWidth+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>                                  `;
				}

				if(neighbourCmp.y + neighbourCmp.height /2 == y + componentMiddleHeight){
					svgContent+= `<line y1=" ` +(y+componentMiddleHeight) +`" x1="0" y2="` +(y + componentMiddleHeight) +`" x2="`+panelWidth+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>`;
				}
				if(neighbourCmp.y + neighbourCmp.height == y + componentHeight){
					svgContent+= `<line y1=" ` +(y + componentHeight) +`" x1="0" y2="` +(y + componentHeight) +`" x2="`+panelWidth+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>`;
				}
			}
		}
		svgContent+=`</svg>`;

		// make wrapper that hosts this dom and add it to content
		var wrapper;
		var prevWrapper = document.getElementById("lineWrapper");
		if(prevWrapper){
			// repurpose old wrapper to host new content
			wrapper = prevWrapper;
		}
		else{
			wrapper= document.createElement('div'); // create wrapping div

		}
		wrapper.setAttribute("id", "lineWrapper"); // set its id
		wrapper.innerHTML= svgContent; //insert string content




		//refs.panelContent.el.dom.firstChild.firstChild.firstChild.appendChild(wrapper);

		refs.panelContent.el.dom.firstChild.firstChild.firstChild.insertAdjacentElement('afterbegin', wrapper);
	},

	createSelection: function(opts) {
		// gets called when user creates new component - by duplicate or create new
		var text = opts.text,
			answers = opts.answers,
			multi = opts.multi,
			component = opts.component;

		if(answers.length === 0) {
			return 'Please specify at least one answer';
		}
		if(answers.filter(function(item) { return item.correct; }).length === 0) {
			return 'Please mark at least one answer as correct';
		}
		if(!multi && answers.filter(function(item) { return item.correct; }).length > 1) {
			return 'Only one correct answer is allowed for single selection';
		}

		var me = this;

		// Testing selection insert Jernej Habjan 2018-07-16

		var questionsStore = me.getStore('QuestionsStoreSlides'),
			treeStoreSlides = me.getStore('TreeStoreSlides');

		// getting all correct answers
		var correctAnswersIds = []; // this array stores ids of correct answers, where ids are generated as sequence numbers

		for (var i = 0; i < answers.length; i++) {
			var element = answers[i];
			if (element.correct === true){
				correctAnswersIds.push(element.id); // adds sequence number of this question
			}
		}

		// getting page id
		var refs = this.getReferences(),
			selection = me.getCurrentSlide();

		if(!selection){
			me.newSlide();
			selection = me.getCurrentSlide();
		}


		var pageGuid = selection.data.id;
		var componentGuid = createGUID();

		var now = new Date();

		// after adding to database add component to view
		// check if we are updating selection or making new -> if(component)-> update, else -> new
		if(component) {
			// updating existing state in store
			var state = component._opts;
			state.question = text;
			state.lookups = Ext.encode(answers);
			state.id = component._opts.id; // keep old id
			state.correctValue = Ext.encode(correctAnswersIds);
			state.fieldType = state.type;
			state.pageId= pageGuid;
			state.lastChanged = now;
			state.changed = 'Y';

			// update question
			var rec = questionsStore.findRecord('id',state.id);
			rec.data = state;
			rec.phantom = true;

			// delete current answers for this question
			var answerRecord = me.getStore('PersonAnswers').findRecord('questionId', state.id); // find record by questionGuid
			if(answerRecord){
				me.getStore('PersonAnswers').remove(answerRecord);
			}

			// redraw
			me.deleteComponent(component, false);
			component = me.insertComponent(state);
			component.fireEvent('click');
		}
		else {
			//adding new record to store

			var record = {
				id : componentGuid,
				pageId: pageGuid,
				question: text,
				created : now,
				lastChanged: now,
				lookups: Ext.encode(answers),
				correctValue: Ext.encode(correctAnswersIds),
				fieldType:  (multi? "Multi" : "Single") + " " + me.cmpTypes.SELECTION
				// this renders to string "Multi selection" or "Single selection"
			};

			// update question store
			questionsStore.add(record)[0].phantom = true;
			// update slide
			treeStoreSlides.findRecord('id', me.getCurrentSlide().id).phantom = true;

			component = me.insertComponent({
				type: me.cmpTypes.SELECTION,
				cls: 'selection',
				html: text,
				options: answers,
				multi: multi,
				id: componentGuid,
				width: opts.width,
				height: opts.height
			});
			component.fireEvent('click');
		}
		me.saveState();
	},

	createResizer: function(cmp) {

		var me = this,
		    snap = me._pageSetup.snap;

		cmp._resizer = Ext.create('Ext.create', 'Ext.resizer.Resizer', {
		    target: Ext.get(cmp),
		    //pinned:true,
		    minWidth: snap,
		    minHeight: snap,
		    heightIncrement: snap,
		    widthIncrement: snap,
		    preserveRatio: false,
		    dynamic: true,
		    transparent: false,
		    handles: 'all', // shorthand for 'n s e w ne nw se sw'
		    listeners: {
		        beforeresize: function(component){
		            component.el.fireEvent('click');
		        },

		        resizedrag:function(component, width, height){
		            component.el._opts.width = width;
		            component.el._opts.height = height;
		            component.el._opts.x = component.el.dom.offsetLeft;
		            component.el._opts.y = component.el.dom.offsetTop;
		            me.drawHelperLines(component);

		            me.showComponentTools(component);
		        },


		        resize: function (component, width, height, e, eOpts) {
		            var prevWrapper = document.getElementById("lineWrapper");
		            if(prevWrapper){
		                prevWrapper.outerHTML = ""; // remove old wrapper
		            }
		            cmp.width = width;
		            cmp.height = height;
		            cmp._opts.width = width;
		            cmp._opts.height = height;

		            // save slide state after resizing element

		            var id = component.target._opts.id; // TODO - this line is changed as of in the dragmove function
		            var currentSlide = me.getCurrentSlide();

		            // THIS FUNCTION NOW WORKS FOR ALL - IMAGES, AUDIO, SELECTIONS, BECAUSE EVERYONE HAS ITS OWN ID

		            // set new info to this new altered component
		            var alteredContent = Ext.decode(currentSlide.data.content);
		            for (var key in alteredContent.components){
		                if(alteredContent.components[key].id == id){

		                    // resizer changes width, height and also x,y
		                    alteredContent.components[key].width = me.round(width); // Todo these lines are changes ofc
		                    alteredContent.components[key].height = me.round(height);

		                    alteredContent.components[key].x = me.round(component.target.dom.offsetLeft);
		                    alteredContent.components[key].y = me.round(component.target.dom.offsetTop);
		                }
		            }
		            // change store and sync
		            var storeItems = me.getStore('TreeStoreSlides').data.items;
		            for(var i = 0; i < storeItems.length; i++){
		                if(storeItems[i].id == currentSlide.id){
		                    storeItems[i].data.content = Ext.encode(alteredContent);
		                    storeItems[i].data.lastChanged = new Date();
		                    storeItems[i].phantom = true;
		                    break;
		                }
		            }
		            me.saveState();
		        }
		    }
		});

	},

	serverSync: function(callback) {
		// calls sync of everything (slides, questions, answers, pageConfig...) - it retrieves data and pushes latest data to server
		// syncs all data with server - this is called on program load and on navigator onLine


		var me = this,
			localStorageData = Ext.decode(localStorage.getItem('mxp_elearning')),
			syncIndicator = Ext.getCmp('syncIndicator'),
			treeStoreSlides = me.getStore('TreeStoreSlides');

		var personAnwersCallback = function(){

			// check if we have any unsubmitted person programs - if so - validate it
			if(localStorageData[me.programId].personProgram && localStorageData[me.programId].personProgram.unsynced){
				me.closePreview(true); // validate program and change button style to default
				localStorageData[me.programId].personProgram.unsynced = false;
				localStorage.setItem('mxp_elearning',Ext.encode(localStorageData));
			}
			if(callback){ callback(); }
		};

		var syncQuestionsCallback = function(){
			// after loading slides, load questions
			me.updateStatusIndicator(true);

			if(me.currentPersonProgram){
				//var params = {programId: me.currentPersonProgram.personTrainingProgramId}; //get all data from current person program id
				var params = {programId: me.programId};
				initialDataSync('PersonAnswers', 'answers', params, personAnwersCallback, 'questionId', me);
			}
			else{
				if (callback){ callback(); }
			}
		};
		var syncStateCallback = function(){


			// get info for current program from database - if it exists, its valid program, otherwise its temp debug program

			var controller = me.getView().up('mainview').down('programs').getController();

			controller.getStore('StorePrograms').load({
				callback: function(){
					rec = controller.getStore('StorePrograms').findRecord('id', me.programId);
					if(rec){
						// sync slides again so we get back apropriate structure in tree view after adding slides when returning from offline
						// TODO - this may be fixed by correctly adding offline slides to storage when retrigering InitialDataSync()
						/* treeStoreSlides.sync({
							callback: function(){
								treeStoreSlides.load({
									params: {programId: me.programId},
									callback: function(records, operation, success){
										print("Slides data reloaded");


				// for(var i = 0; i < treeStoreSlides.data.items.length;i++){
				// 	var entry = treeStoreSlides.data.items[i];
				// 	if(entry.data.categoryId == App.ProgramPageCategoriesEnum.Chapter && !entry.data.children){
				// 		entry.data.children = [];
				// 	}
				// }







									}
								});
							}
						}); */
					}else{
						console.warn("current program doesnt exist in database - wont we resyncing slides");
					}
				}
			});

			var params = {programId: me.programId};
			initialDataSync('QuestionsStoreSlides', 'questions', params, syncQuestionsCallback, 'id', me);

		};

		// update sync icon
		syncIndicator.removeCls('fa-check fa-refresh fa-spin fa-exclamation-triangle warning success');
		syncIndicator.addCls("fa-spin fa-refresh warning");
		syncIndicator.tooltip.html = 'Syncing';

		if(localStorageData[me.programId].pageSetup){ // TODO retrieve it later from database
			me._pageSetup = localStorageData[me.programId].pageSetup;
		}
		var params = {programId: me.programId};
		initialDataSync('TreeStoreSlides', 'slides', params, syncStateCallback, 'id', me);


	},

	renderThumbnails: function() {
		// TODO - Jernej Habjan 2018-07-12
		// Trying to replace slide icon in treeview by rendered content


		// todo - check if there are any children - possible crash here

		// get all currently shown nodes in tree view - only parent of collapsed nodes is visible





		var me = this,
			refs = me.getReferences(),
			treeStore = me.getStore('TreeStoreSlides');


		var callback = function(url, base64EncodedImg){


			var treeView = refs.treeSlides.el.dom.children[0].children[1].children[0].children[1];
			if(!treeView){
				console.warn("Some error triggered after duplicate");
				return;
			}
			treeView = treeView.children;



			for (var i=0, n=treeView.length; i < n; i++){

				var children = treeView[i].children[0].children[0].children[0].children[0].children;
				var slide = children[children.length - 2]; // slots before that occupy indents in tree view, slot after that is text

				// uncomment this if to allow rendering on all tree nodes - and not only on slides
				if(slide.classList.contains("x-tree-icon-leaf")){ // check if it is slide
					//slide.outerHTML = '<div role="presentation" class="  x-tree-icon"><img src="https://www.vaporfi.com.au/media/catalog/product/cache/34/thumbnail/600x600/9df78eab33525d08d6e5fb8d27136e95/v/z/vz_eliquid_juicy_red_apple.jpg" style="width:20px; height:20px;"></div>';

					slide.outerHTML = '<div role="presentation" class="  x-tree-icon"><img src="' + url + '" style="width:20px; height:20px;"></div>';

					// Todo - replace apple photo with rendered slide with scale of 20, 20
				}
			}
		};

		me.captureSlide(callback);
	},

	getNumQuestions: function() {
		var me = this;
		//return Object.keys(Ext.decode(localStorage.getItem('mxp_elearning'))[me.programId].questions).length;
		return me.getStore('QuestionsStoreSlides').data.items.length;
	},

	updateStatusIndicator: function(synced) {
		var me = this,
			localStorageData = Ext.decode(localStorage.getItem('mxp_elearning')),
			syncIndicator = Ext.getCmp('syncIndicator');

		if(synced){
			syncIndicator.removeCls('fa-check fa-refresh fa-spin fa-exclamation-triangle warning success');
			syncIndicator.addCls("fa-check success");
			syncIndicator.tooltip.html = 'Synced';

		}
		else{
			syncIndicator.removeCls('fa-check fa-refresh fa-spin fa-exclamation-triangle warning success');
			syncIndicator.addCls("fa-exclamation-triangle warning");
			syncIndicator.tooltip.html = 'Not Synced';


		}
		// not initialized when duplicating programs
		if(!localStorageData[me.programId]){
			localStorageData[me.programId] = {};
		}
		if(!localStorageData[me.programId].pageSetup){
			localStorageData[me.programId].pageSetup = {};
		}
		// change state of this program sync state so it can be visible in programs tab if this program is synced or not
		localStorageData[me.programId].pageSetup.programSynced = synced;
		print("setting page setup programSynced to", synced);
		localStorage.setItem('mxp_elearning', Ext.encode(localStorageData));
	},

	validatePersonProgram: function() {
		var me = this,
			refs = me.getReferences(),
			personProgramsStore = me.getStore('PersonPrograms'),
			personAnswersStore = me.getStore('PersonAnswers'),
			questionsStore = me.getStore('QuestionsStoreSlides');

		// we / timer toggled preview off - validate forms and submit
		// here we can read the records id to use in posting answers
		// add completion time minutes to initial programStarted time



		// iterate through questions and check if answer has been added to store - if it hasnt, still create an answer for this question
		// this is a solve to a bug that when unchecking everything at multi-select, we dont post an answer and than retrieve previous answer back
		for(var i = 0; i < questionsStore.data.items.length; i++){
			var question = questionsStore.data.items[i].data;
			// check if answer exists
			var answerExists = personAnswersStore.findRecord('questionId', question.id);
			if(!answerExists){
				var now = new Date();
				var recordAnswers = {
					questionId: question.id,
					id: createGUID(),
					created: now,
					lastChanged: now,
					personProgramId: me.currentPersonProgram.personTrainingProgramId,
					answer:{},
					score: 0 // TEMP - TODO CHANGE RECORD AFTER EVALUATING
				};
				// add all answers for this question as false
				var answersTEMP = Ext.decode(question.lookups);
				for(var j = 0; j < answersTEMP.length; j++){
					recordAnswers.answer[j] = false;
				}recordAnswers.answer = Ext.encode(recordAnswers.answer);

				// add this new record to store
				var answerRec = personAnswersStore.add(recordAnswers)[0];
				answerRec.phantom = true;
			}
		}

		// GOOD TO KNOW - batchActions is disabled on store, so every request is handled on its own ->batchActions: false,

		// get scores for each question and total
		var programScore = me.evaluate();
		var questionsScores = programScore.questions;
		var totalProgramScore = programScore.totalProgramScore;

		// submit answers to server - these answers have written score in them
		personAnswersStore.sync();
		me.saveState();



		if(!me.currentPersonProgram){
			console.warn("for some reason current person program id is not set - it should be created new if person doesnt have any records yet or it should be recieved from store.");
			return;
		}

		// get score results:
		var scoreResults;

		if(me.currentPersonProgram.attempt < me.programData.maxAttemptsTrainingMode + me.programData.maxAttemptsScoreMode){
			if(totalProgramScore >= me.programData.passScore){
				// we passed
				scoreResults = App.ProgramStatuses.Passed;


				print("User", App.person, "has been awarded certificate", App.CoursesAndCertificates[me.programData.certificateFileName]);
				print("todo- show certificate modal window here");

				me.showCertificate({
					certificateName: App.CoursesAndCertificates[me.programData.certificateFileName]
				});

			}else{
				// we tried non -last time and we failed - status is chagned to discontinued
				scoreResults = App.ProgramStatuses.Discontinued;
			}
		}else{
			if(totalProgramScore < me.programData.passScore){
				// if we tried last time and we didn't get enough we failed
				scoreResults = App.ProgramStatuses.Failed;
			}else{
				// we tried last time and we passed
				scoreResults = App.ProgramStatuses.Passed;
			}
		}


		var existingRecord = personProgramsStore.findRecord('personTrainingProgramId', me.currentPersonProgram.personTrainingProgramId);
		var alteredRecord = {
			personProgramGuid: me.currentPersonProgram.personTrainingProgramId,
			lastChanged: new Date(),
			programCompleted: new Date(),
			programStatusId: scoreResults,
			changed: 'Y'
		};
		// add new content to this record and update it
		existingRecord.data = alteredRecord;
		existingRecord.phantom = true;
		personProgramsStore.sync();


		// temp print text to show user that program has been evaluated
		var status = "";
		for(var key in App.lookups.ProgramStatuses){
			if(App.lookups.ProgramStatuses[key].id == scoreResults){
				status = App.lookups.ProgramStatuses[key].text;
			}
		}
		Ext.toast("Program successfully validated with score " + totalProgramScore + " and score result " + status);
	},

	startPreviewTimer: function() {
		// this timer is also started when returning on editSlides page so it auto removes previewing (continue) label
		var me = this,
			refs = me.getReferences();
		if(me.previewTimer){
			// preview timer already exists so dont make another interval
			return;
		}
		// Update the count down every 1 second
		me.previewTimer = setInterval(function() {
			// add completion time minutes to initial programStarted time
			var endTime = new Date(new Date(me.currentPersonProgram.programStarted).getTime() +
								   me.programData.completionTime * 60000); // completion time in database is in minutes
			var now = new Date();

			// Find the distance between now an the count down date
			var distance = endTime.getTime() - now.getTime();

			// Time calculations for days, hours, minutes and seconds
			var days = Math.floor(distance / (1000 * 60 * 60 * 24));
			var hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
			var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
			var seconds = Math.floor((distance % (1000 * 60)) / 1000);


			var timerCountdownText = refs.toolbarPreview.el.down('#timerCountdown');
			timerCountdownText.dom.innerHTML = "Remaining: " + hours + "h " + minutes + "m " + seconds + "s ";


			//print("timer interval","Remaining: " + hours + "h " + minutes + "m " + seconds + "s " );
			// If the count down is finished, write some text
			if (distance < 0) {
				clearInterval(me.previewTimer);

				timerCountdownText.dom.innerHTML = "EXPIRED";
				Ext.toast("Time is up! We will evaluate your score.");

				me.closePreview(true);


			}
		}, 1000);

	},

	showCertificate: function(opts) {
		var me = this;

		certificateWindow = me.getView().add({ xtype: 'certificate' });
		certificateWindow.getController().show(opts);
	},

	captureSlide: function(callback) {

		var me = this,
			refs = me.getReferences();


		// TODO - Jernej Habjan 2018-08-16 - saving current slides' thumbnails in
		// localStorageData[me.programId].slides[me.getCurrentSlide().id].content.thumbnail


		//var thumbnailb64 = btoa(me.renderThumbnail(me.getCurrentSlide()));

		function dataURItoBlob(dataURI) {
		    // convert base64/URLEncoded data component to raw binary data held in a string
		    var byteString;
		    if (dataURI.split(',')[0].indexOf('base64') >= 0)
		        byteString = atob(dataURI.split(',')[1]);
		    else
		        byteString = unescape(dataURI.split(',')[1]);

		    // separate out the mime component
		    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

		    // write the bytes of the string to a typed array
		    var ia = new Uint8Array(byteString.length);
		    for (var i = 0; i < byteString.length; i++) {
		        ia[i] = byteString.charCodeAt(i);
		    }

		    return new Blob([ia], {type:mimeString});
		}

		html2canvas(refs.panelContent.el.dom,
					{
			scale:0.1
		}).then(canvas => {

		    //document.body.appendChild(canvas);
			//print("canvas",   btoa(canvas.toDataURL('image/png', 0.1)));
			var dataURL = canvas.toDataURL('image/jpeg', 0.5);

			var currentSlide = me.getCurrentSlide();
			var rec = me.getStore("TreeStoreSlides").findRecord('id', currentSlide.data.id);

			if(!rec){
				return;
			}

			var content =  Ext.decode(rec.data.content);
			content.thumbnail = LZString.compressToEncodedURIComponent(dataURL);
			rec.data.content = Ext.encode(content);

			rec.phantom = true;

			print("printing record", rec);


			var blob = dataURItoBlob(dataURL);


			/*
			var img = new Image();
			img.src = URL.createObjectURL(blob);
			document.body.appendChild(img);
		*/


			callback(URL.createObjectURL(blob), LZString.compressToEncodedURIComponent(dataURL));
			// dataUrl = atob(Base64String.decompress(...))
		});
		// END ENCODING PIC


	},

	clean: function(silently) {
		var me = this,
			slidesStore = me.getStore('TreeStoreSlides'),
			questionsStore = me.getStore('QuestionsStoreSlides'),
			answersStore = me.getStore('PersonAnswers'),
			programsStore = me.getStore('PersonPrograms');

		if(silently){
			slidesStore.loadData([],false);
			slidesStore.getRootNode().removeAll(false, true,true);
			questionsStore.loadData([],false);
			answersStore.loadData([],false);
			programsStore.loadData([],false);
			return;
		}

		// loud delete all stores - used when deleting program


		// clean all stores
		slidesStore.loadData([],false);
		slidesStore.getRootNode().removeAll(false, true,true);
		questionsStore.loadData([],false);
		answersStore.loadData([],false);
		programsStore.loadData([],false);


		// load all data into stores so you can delete this data after


		slidesStore.load({
			params:  {programId: me.programId},
			callback: function(){
				questionsStore.load({
					params:  {programId: me.programId},
					callback: function(){
						answersStore.load({
							params:  {programId: me.programId},
							callback: function(){


								for(var i = 0; i < slidesStore.data.items.length; i++){
									var rec = slidesStore.data.items[i];
									rec.parentNode.removeChild(rec);
									//slidesStore.remove(slidesStore.data.items[i]);
								}
								slidesStore.sync();
								for(var i = 0; i < questionsStore.data.items.length; i++){
									questionsStore.remove(questionsStore.data.items[i]);
								}
								for(var i = 0; i < answersStore.data.items.length; i++){
									answersStore.remove(answersStore.data.items[i]);
								}
							}
						});
					}
				});
			}
		});


		programsStore.load({
			params: { personId: App.personId, programId: me.programId },
			callback: function(){
				for(var i = 0; i < programsStore.data.items.length; i++){
					programsStore.remove(programsStore.data.items[i]);
				}
			}
		});




		/*Ext.Promise.all(
			[
				slidesStore.load({
					params:  {programId: me.programId}
				}),
				questionsStore.load({
					params:  {programId: me.programId}
				}),
				answersStore.load({
					params:  {programId: me.programId}
				}),
				programsStore.load({
					params: { personId: App.personId, programId: me.programId }
				}),
			]).then(function(results) {
			print("all promises returned");


			for(var i = 0; i < slidesStore.data.items.length; i++){
				var rec = slidesStore.data.items[i];
				rec.parentNode.removeChild(rec);
				//slidesStore.remove(slidesStore.data.items[i]);
			}
			slidesStore.sync();
			for(var i = 0; i < questionsStore.data.items.length; i++){
				questionsStore.remove(questionsStore.data.items[i]);
			}
			for(var i = 0; i < answersStore.data.items.length; i++){
				answersStore.remove(answersStore.data.items[i]);
			}
			for(var i = 0; i < programsStore.data.items.length; i++){
				programsStore.remove(programsStore.data.items[i]);
			}

		});
		*/




	},

	close: function(owner, tool, event) {
		var me = this;
		var yesCallback = function(){ // if user selects yes on close preview, set active item to programs, else do nothing

			// clear all stores so next program we are viewing wont be using this programs data
			// to silently remove data from store - use loadData([],false) !!
			// remove all data from these stores - silently
			me.clean(true);


			window.removeEventListener('online',  me.connectionChange);
			window.removeEventListener('offline',  me.connectionChange);

			me.redirectTo('training-programs');
		};

		if(me.previewing){ // only if we are previewing show close dialog
			me.togglePreview(false, yesCallback); // show close dialog for preview
		}else{
			// if we are not previewing, its safe to call yesCallback
			yesCallback();
		}
	},

	createTooltip: function(component, eOpts) {
		// this function could be basic binding but if it is, defaultListenerScope becomes true and then store bindings dont work!!!!!!!!

		component.tooltip = Ext.create('Ext.tip.ToolTip', {
			target: component.id,
			html: 'Not Synced'
		});


	},

	onTreeDragDrop: function(treeviewdragdrop) {
		var me = this,
			refs = me.getReferences();

		var treeStoreSlides = me.getStore('TreeStoreSlides');

		// we need to mark every slide as dirty, as we cannot know how the selection was changed
		for (var i = 0; i < treeStoreSlides.data.items.length; i++){
			var rec = treeStoreSlides.data.items[i];
			rec.dirty = true;
		}
		me.saveState();
		refs.treeSlides.setSelection(me.getCurrentSlide());

	},

	onTreeItemRename: function(editor, context, eOpts) {
		// after rename save state
		this.saveState();
	},

	onTreeItemSelect: function(rowmodel, record, index, eOpts) {
		// loading slide state for both sections and slides, because creating title every time caused sync with database

		var me = this,
			refs = me.getReferences();

		me.loadSlideState(record);

		// if(record.isLeaf()) {
		//     this.loadSlideState(record);
		// }
		// else {
		//     this.clearSlidePanel();
		//
		//     // Todo -insert title is causing another sync with database
		//     this.insertTitle('Section ' + record.get('title'));
		// }

	},

	onTreeSlidesDeselect: function(rowmodel, record, index, eOpts) {

		this.clearSlidePanel();


	},

	onTreeItemCollapse: function(nodeinterface, eOpts) {
		print("tree slides item colapse",nodeinterface, eOpts);
		var me = this,
			refs = me.getReferences();
		me.saveState();
		refs.treeSlides.setSelection(nodeinterface);
	},

	onEditBoxReady: function(component, width, height, eOpts) {
		var me = this,
			refs = me.getReferences();

		me.previewing = false; // used for toggling event actions when previewing or not
		me.currentlyEditing = false;

		me._pageSetup = {
			snap: 25,
			width: 800,
			height: 600,
			headerHeight: 50,
			footerHeight: 50,
			padding: 50,
			background: null,
			programSynced: true
		};

		me.cmpTypes = {
			HTML: 'html',
			TITLE: 'title',
			TEXT: 'text',
			IMAGE: 'image',
			AUDIO: 'audio',
			VIDEO: 'video',
			SELECTION: 'selection'
		};

		loadLookups();

		component.el.on('mouseup', function(e, t) {
			// hiding component tools if component itself (like bodyPanel, ImageComponent...) didn't stop click event to backpropagate
			if(me._dragged){ // if we were just dragging - dont trigger mouse up event
				me._dragged = null;
				return;
			}
			if(!e.ctrlKey && !e.shiftKey){
				// if we clicked on background without holding shift or ctrl key - remove all selected components
				// if we are holding shift or ctrl key, we are multiselecting and we might have clicked on background by accident
				me.hideComponentTools();

				for(var i = 0; i < me.allComponents.length; i++){
					me.allComponents[i].fireEvent('deselect');
				}
				me._selectedComponents = [];
			}
		});

		document.addEventListener("keydown", function onPress(event) {
			var KEY_DELETE = 46;
			var KEY_A = 65;
			if(me._selectedComponents.length){
				if(event.keyCode === KEY_DELETE){
					for(var i = 0; i < me._selectedComponents.length; i++){
						var cmp = me._selectedComponents[i];
						cmp.fireEvent('_delete');
					}
					me.hideComponentTools();

				}
			}
			if(event.keyCode === KEY_A){
				if (event.ctrlKey) {
					if(!me.currentlyEditing){
						// clear all selected components
						me._selectedComponents = [];
						if(!me.previewing && me.allComponents.length){
							me._selectedComponents = me.allComponents; //select all components
							// iterate through all components - they are getting reset on slide deselect and on editSlides load
							for(var i = 0; i < me.allComponents.length; i++){
								me.allComponents[i].addCls('selected');
							}
							me.showComponentTools( me.allComponents[ me.allComponents.length-1]);
						}
						event.preventDefault();
					}
				}
			}
		});

		// create online / offline event listenere - when coming back online, we want to sync localstorage with database
		me.connectionChange = function() {
			if (navigator.onLine){
				var callback = function(){
					var currentSlide = me.getCurrentSlide();
					me.getReferences().treeSlides.setSelection(null);
					me.getReferences().treeSlides.setSelection(currentSlide); // retrigger current slide to update
					me.saveState(); // save ALL data that is after all initial data syncs to localstorage
					Ext.toast('Welcome back online! Content saved on server.');
				};
				me.serverSync(callback); // calls sync of everything (slides, questions, answers, pageConfig...) - it retrieves data and pushes latest data to server

			}else{
				Ext.toast('We went offline! Content is still saved locally. Reconnect to save content with server.');
			}
		};

		// add eventlistenere on fullscreen change to remove this panel on fullscreen off
		var screen_change_events = ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "MSFullscreenChange"];

		for (var i in screen_change_events){
			document.addEventListener(screen_change_events[i], function( event ) {
				// The event object doesn't carry information about the fullscreen state of the browser,
				// but it is possible to retrieve it through the fullscreen
				if (document.webkitFullscreenElement ||  document.fullscreenElement || document.mozFullscreenElement || document.msFullscreenElement ) {
				}else{
					// The target of the event is always the document,
					// but it is possible to retrieve the fullscreen element through the API
					refs.slideNavigation.getController().closeFullscreen();
				}
			});
		}

	},

	onTreeStoreRemove: function(store, records, index, isMove, eOpts) {
		if(!navigator.onLine){
			var me = this;
			for(var i = 0; i < records.length; i++){
				var deletedRec = records[i];
				var recId = deletedRec.id;
				writeDeleted(recId, 'slides', me, false, me.programId);
			}
		}
	},

	onQuestionsRemove: function(store, records, index, isMove, eOpts) {
		if(!navigator.onLine){
			var me = this;
			for(var i = 0; i < records.length; i++){
				var deletedRec = records[i];
				var recId = deletedRec.id;
				writeDeleted(recId, 'questions', me, false, me.programId);
			}
		}
	}

});
