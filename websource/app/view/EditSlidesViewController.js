/*
 * File: app/view/EditSlidesViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.3.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.5.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.5.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('eLearning.view.EditSlidesViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.editslides',

    load: function(opts) {
        opts = Ext.applyIf(opts || {}, {
            program: null
        });

        var me = this,
            refs = me.getReferences();

        refs.panelHeader.setTitle(opts.program.get('name'));

    },

    newSection: function() {
        console.log("creating new section" ,"TODO -leaf is here set to true, but it should be pulled from database if this section has any children");
        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides');

        var data = {
            id: createGUID(),
            title: 'New Section',
            content: null,
            expanded: false,
            children: [],
            categoryId : App.ProgramPageCategoriesEnum.Chapter,
            scoreMethod: 'A',
            sequence: 1234

        };

        var parentNode = /*refs.treeSlides.getSelection()[0] ||*/ store.getRoot();

        slide = parentNode.appendChild(data);


        refs.treeSlides.setSelection(slide);

        //me.saveSlideState(slide);

    },

    newSlide: function() {
        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides'),
            parentNode = refs.treeSlides.getSelection()[0] || store.getRoot(),
            slide,
            data = {
                id: createGUID(),
                // sequence: sequence,
                title: 'New Slide', // + sequence,
                content: null,
                expanded: true,
                leaf: true,
                isSlide : true,
                categoryId : App.ProgramPageCategoriesEnum.Page,
                scoreMethod: 'A',
                sequence: 1234
            };

        if(parentNode.isLeaf()) {
            parentNode = parentNode.parentNode;
        }

        slide = parentNode.appendChild(data);
        refs.treeSlides.setSelection(slide);
        me.saveSlideState();
    },

    deleteSlide: function(slide) {
        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides');

        slide = slide || me.getCurrentSlide();

        if(slide) {
            console.log("printing current slide", slide);

            var nextSlideIdx = store.indexOf(slide) - 1,
                nextSlide = store.getAt(nextSlideIdx >= 0 ? nextSlideIdx : 1),
                components = (Ext.decode(slide.get('content') || '{}').components);

            if(components && components.length > 0) {
                Ext.Msg.confirm('Delete slide', 'Are you sure?', function(btn) {
                    if(btn == 'yes') {

                        slide.parentNode.removeChild(slide);
                        me.saveState();
                        me.clearSlidePanel();
                        refs.treeSlides.setSelection(nextSlide);


                    }
                });
            }
            else {
                slide.parentNode.removeChild(slide);
                me.saveState();
                me.clearSlidePanel();
                refs.treeSlides.setSelection(nextSlide);

            }
        }
    },

    getCurrentSlide: function() {
        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides');

        var currentSlideIdx = store.indexOf(me.currentSlide);


        me.currentSlide = refs.treeSlides.getSelection()[0] || store.getAt(currentSlideIdx);


        return me.currentSlide;
    },

    nextSlide: function() {
        // variable to recursively descend to first slide - if its set to false, we also visit sections
        var REC_TO_SLIDE = true;

        // if (REC_TO_SLIDE &&  this.getNumSlides() < 2){
        //     // there is 1 or 0 slides and recursion is set to true - which means we cannot visit sections so return
        //     return;
        // }

        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides'),
            slide = me.getCurrentSlide(),
            nextSlideIdx = store.indexOf(slide) + 1,
            nextSlide = store.getAt(nextSlideIdx);

        if(nextSlide) {

            refs.treeSlides.setSelection(nextSlide);
            if (nextSlide.data.leaf === false){



                me.nextSlide();

                if(REC_TO_SLIDE){
                    // recursively iterate to leaf slide through section
                    if (this.getNumSlides() === 0){
                        console.log("cannot switch recursively to next slide", "no slides exist");
                        return;
                    }
                    if (me.getCurrentSlide().data.leaf === false){
                        me.prevSlide();
                    }
                }



            }
        }


    },

    prevSlide: function() {


        // variable to recursively ascend to first remaining slide - if its set to false, we also visit sections
        var REC_TO_SLIDE = true;

        // if (REC_TO_SLIDE &&  this.getNumSlides() < 2){
        //     // there is 1 or 0 slides and recursion is set to true - which means we cannot visit sections so return
        //     return;
        // }

        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides'),
            slide = me.getCurrentSlide(),
            prevSlideIdx = store.indexOf(slide) - 1,
            prevSlide = store.getAt(prevSlideIdx);


        if(prevSlide) {
            refs.treeSlides.setSelection(prevSlide);
            if (prevSlide.data.leaf === false){

                me.prevSlide();

                if(REC_TO_SLIDE){
                    // recursively iterate to leaf slide through section
                    if (this.getNumSlides() === 0){
                        console.log("cannot switch recursively to prev slide", "no slides exist");
                        return;
                    }


                    if (me.getCurrentSlide().data.leaf === false){
                        me.nextSlide();
                    }

                }


            }



        }
    },

    setBackground: function(src) {
        var me = this,
            refs = me.getReferences();

        me._pageSetup.background = src;

        if(src) {
            Ext.getCmp('panelContent').setStyle('background', 'url(' + src + ')');
        }
        else {
            Ext.getCmp('panelContent').setStyle('background', null);
        }
    },

    togglePreview: function(preview) {
        var me = this,
            refs = me.getReferences();

        me.previewing = preview; // setting current previewing state

        //refs.panelMenu.setVisible(!preview); // commented so navigation tree is visible even when solving quiz
        refs.toolbarEdit.setVisible(!preview);
        refs.toolbarPreview.setVisible(!!preview);
        refs.panelContent[preview ? 'removeCls' : 'addCls']('edit');
        refs.panelContent[preview ? 'addCls' : 'removeCls']('preview');

        refs.panelSlide.setMargin(preview ? '10' : '10 10 10 0');


        // retarget this slide - this redraws current slide without dragger and sizer
        var currentSlide = me.getCurrentSlide();
        refs.treeSlides.setSelection(null);
        refs.treeSlides.setSelection(currentSlide);


        if(preview) {
            me.saveSlideState(me.getCurrentSlide());
            var firstSlide = refs.treeSlides.store.getAt(0);
            refs.treeSlides.setSelection(firstSlide);
            // on panel toggle - drop down the sections to first actual slide
            if (firstSlide.data.leaf === false){
                me.nextSlide();
            }
        }else{
            // we / timer toggled preview off - validate forms and submit
            me.evaluate();
        }



        // Switching countdown timer when toggling preview - preview automatically closes when timer turns to 0
        // TODO - is this secure - should't countdown occur on server side - is it?
        var counter = 1000;

        var taskPoll = {
            run: function(){
                counter -= 1;
                if( counter < 1 ){
                    Ext.TaskManager.stop(taskPoll);

                    me.togglePreview();
                } else {
                    var timerCountdownText = refs.toolbarPreview.el.down('#timerCountdown');
                    timerCountdownText.dom.innerHTML = "00:" + counter.toString();
                }
            },
            interval: 1000
        };

        if(preview) {
            Ext.TaskManager.start(taskPoll);

        }else{
            Ext.TaskManager.stop(taskPoll);

        }
    },

    getFreePosition: function() {
        var me = this,
            refs = me.getReferences(),
            snap = me._pageSetup.snap,
            pos = {
                x: snap*2,
                y: snap*2,
                width: me.round(refs.panelContent.el.getWidth() - 2*snap*2),
                height: snap*2
            };

        Ext.each(refs.panelContent.el.query('.html-component'), function(component) {
            pos.y = me.round(Math.max(pos.y, component.y + component.height + snap));
        });

        return pos;
    },

    getSlideComponents: function() {
        return this.getReferences().panelContent.el.query('.html-component');
    },

    getCurrentState: function() {
        var me = this,
            refs = me.getReferences(),
            slides = Ext.clone(Ext.pluck(refs.treeSlides.store.getRange(), 'data')).map(function(node) {


                console.log("printing current state node", node);

                return cleanTreeNodeData(node);


            });
        data = {
                slides: slides,
                pageSetup: me._pageSetup
            };

        return data;
    },

    saveSlideState: function(slide) {
        var me = this,
            refs = me.getReferences(),
            content = {
                components: []
            };

        slide = slide || me.getCurrentSlide();

        if(slide) {

            Ext.each(me.getSlideComponents(), function(component) {
                if(component._opts.type == me.cmpTypes.SELECTION){


                    // if its question, append only guid of this question to content components
                    var _opts = Ext.clone(component._opts);

                    var _optsNew = {"type": _opts.type, "questionGuid": _opts.questionGuid };
                    console.log("printing opts", _opts);
                    console.log("printing new opts", _optsNew);

                    content.components.push(_optsNew);




                    // uncomment line below to append whole question content to slide instead of only id
                    //content.components.push(component._opts); // TODO TEMP


                }else{
                     content.components.push(component._opts);
                }
                console.log("saveSlideState  printing content.componentss.push(comonent._opts)",content.components );


            });

            slide.set('content', Ext.encode(content));

            me.saveState();


        }
    },

    loadSlideState: function(slide) {
        var me = this,
            refs = me.getReferences(),
            parentEl = refs.panelContent.el.down('#html-slide');

        me.clearSlidePanel();

        if(slide) {

            console.log("loadSlideState - printing slide", slide);
            var content = Ext.decode(slide.get('content') || '{}');

            Ext.each(content.components, function(component) {
                this.insertComponent(component);
            }, this);

            me._selectedComponent = null;
        }
    },

    clearSlidePanel: function() {
        var me = this,
            refs = me.getReferences(),
            parentEl = refs.panelContent.el.down('#html-slide');

        me.hideComponentTools();

        Ext.each(parentEl.query('.html-component'), function(component) {
            parentEl.removeChild(component);
        }, this);
    },

    addComponentListeners: function(item) {
        var me = this,
        item = Ext.get(item);

        item.on('click', function(e, t) {
            if(e.stopPropagation){
                e.stopPropagation();
            }


            var prevItem = me._selectedComponent;

            if(prevItem) {
                me._selectedComponent.removeCls('selected');
                if(me._tools) {
                    me._tools = null;
                }

                // if(prevItem == item) {
                //     me.hideComponentTools();
                //     me._selectedComponent = null;
                //     return;
                // }
            }
            if(!me.previewing){
                // not previewing - show edit tools
                me._selectedComponent = item;
                me._selectedComponent.addCls('selected');
                me.showComponentTools(item);
            }else{
                // previewing

                // Handle checkboxes and radio buttons
                var SELECTED_VALUE = t.getAttribute('idx'); // idx have checboxes and radio buttons
                if (SELECTED_VALUE){
                    // getting array from html collection
                    var answers = Array.from(item.dom.children[0].children); // to change dom style
                    var answers_js =  item.el._opts.options; // to update javascript object and set answer to true/false


                    answers.shift(); // remove first text item (text) - all other are radio / check buttons

                    var type = answers[0].getAttribute('type');

                    switch(type) {
                    case 'radio':
                        for (var i = 0, len = answers.length; i < len; i++) {
                            answers[i].classList.remove('selected');
                            answers_js[i].answer = false;
                        }
                        answers[SELECTED_VALUE].classList.add('selected');
                        answers_js[SELECTED_VALUE].answer = true;
                        break;
                    case 'check':
                        answers[SELECTED_VALUE].classList.toggle("selected");
                        answers_js[SELECTED_VALUE].answer = !answers_js[SELECTED_VALUE].answer;
                        break;
                    default:
                        console.error("Caller - addComponentListeners", "Unsupported component type" ,type);
                    }
                    //me.saveState();


                    console.log("Todo - get question id here and call post request to store on table TrainingProgramsAnswers");
                    console.log("printing question id", item._opts.questionGuid);


                }


            }
        });

        // if(!me.previewing){ - is in each of these 4 functions which checks for condition when event is fired - this is usefull
        // when switching back and forth from preview and remaining on same slide

        item.on('dblclick', function(e, t) {
            if(!me.previewing){
                me.editComponent(item);
            }
        });

        item.on('_edit', function(e, t) {
            if(!me.previewing){
                me.editComponent(item);
            }
        });

        item.on('_duplicate', function(e, t) {
            if(!me.previewing){
                me.duplicateComponent(item);
            }
        });

        item.on('_delete', function(e, t) {
            if(!me.previewing){
                me.deleteComponent(item);
                me.hideComponentTools(item);
            }
        });

    },

    showComponentTools: function(component) {
        var me = this;

        if(!me._componentTools) {
            me._componentTools = me.getView().add({ xtype: 'edittools' });
        }
        me._componentTools.getController().show({ component: component });
    },

    hideComponentTools: function(component) {
        var me = this;

        if(!me._componentTools) {
            me._componentTools = me.getView().add({ xtype: 'edittools' });
        }
        me._componentTools.close();

    },

    insertComponent: function(opts) {
        console.log("called insert component with opts", opts);

        opts = Ext.applyIf(opts || {}, {
            type: null,
            height: null,
            width: null,
            x: null,
            y: null,
            html: '',
            options: [],
            multi: false,
            src: '',
            cls: null,
            style: null
        });

        if (!opts.type) {
            Ext.Msg.alert('Error', 'No component type');
        }

        if (opts.cls && typeof opts.cls == "string") {
            opts.cls = [opts.cls];
        }

        var me = this,
            refs = me.getReferences(),
            pos = me.getFreePosition(),
            snap = me._pageSetup.snap,
            parentEl = refs.panelContent.el.down('#html-slide'),
            cmp = document.createElement('div');

        if (!me.getCurrentSlide()) {
            me.newSlide();
        }

        // set size
        // if(opts.type == 'image' && opts.src) {
        //     // determine image size
        //     var img = new Image();

        //     img.onload = function() {
        //         cmp.width = me.round(isNull(opts.width, img.width));
        //         cmp.height = me.round(isNull(opts.height, img.height));
        //         cmp.style.width = cmp.width + 'px';
        //         cmp.style.height = cmp.height + 'px';
        //     };
        //     img.src = opts.src;

        //     // show image as background
        //      cmp.style.backgroundImage = 'url(' + opts.src + ')';
        // }
        // else {
        cmp.width = opts.width = me.round(isNull(opts.width, pos.width));
        cmp.height = opts.height = me.round(isNull(opts.height, pos.height));
        cmp.style.width = cmp.width + 'px';
        cmp.style.height = cmp.height + 'px';
        // }

        // set classes
        cmp.classList.add('html-component');

        // set position
        cmp.x = opts.x = isNull(opts.x, pos.x);
        cmp.y = opts.y = isNull(opts.y, pos.y);

        cmp.style.left = cmp.x + 'px';
        cmp.style.top = cmp.y + 'px';

        // set content
        var content = document.createElement('div');
        var html = opts.html;


        if (opts.type == me.cmpTypes.SELECTION && opts.options) {

            opts.cls = [me.cmpTypes.SELECTION];
            cmp.height = 100; // TODO temp component height because we cannot store height in database
            cmp.style.height = cmp.height + 'px';// TODO - in future we might need to assign height dynamically from reading html + css height - maybe use "offsetHeight"



            console.log("printing opts in insert component", opts);
            if(!opts.questionGuid){
                console.log("no question guid yet.. return -- maybe insert new component here");
                /*console.log("inserting new selection component here - this below is org code");
                console.log("printing opts at SELECTION insertComponent", opts);

                html = '<div clas="text">' + html + '</div>';

                Ext.each(opts.options, function (option, index, allItems) {
                    var cls = ['option', (opts.multi ? 'check' : 'radio')];

                    if (option.correct) {
                        cls.push('correct');
                    }
                    if (option.answer) {
                        cls.push('selected');
                    } else {
                        // add answer parameter that is getting set when checking and unchecking answer
                        option.answer = false;
                    }
                    // added two custom attributes idx which is index of element (starting with 0) and type which can contain chech or radio
                    html += '<div class="' + cls.join(' ') + '" idx=' + index + ' type=' + (opts.multi ? 'check' : 'radio') + '>' + option.text + '</div>';
                });
                console.log("printing html atm", html, opts);



                // TODO - this is after end
                content.innerHTML = html;
                content = cmp.appendChild(content);

                cmp = parentEl.dom.appendChild(cmp);

                cmp._opts = opts;
                cmp.type = opts.type;

                extCmp = Ext.get(cmp);
                extCmp._opts = opts;
                extCmp.type = opts.type;




                me.addComponentListeners(cmp);

                return extCmp;*/
            }



            // insert selection has been called with specific id, so we must retrieve it from database end spawn it here
            var store = me.getStore('QuestionsStoreSlides');

            console.log("todo -add id which question should we request from server which is in opts somewhere", opts );
            console.log("getting this question", opts.questionGuid);
            store.load({
                params:{questionGuid: opts.questionGuid},// maybe this way param??????


                callback: function(records, operation,success) {

                    console.log("callback recieved on getBack question" ,records);

                    // getting info for question from database
                    var record = records[0].data;
                    opts.type = record.fieldType;
                    opts.options = Ext.decode(record.lookups);
                    html = record.question;

                    opts.multi = true; // todo we dont store in database if question is multi answer or not
                    opts.html = html;
                    opts.cls = [me.cmpTypes.SELECTION];
                    opts.id = opts.questionGuid;



                    // same as below - TODO
                    html = '<div clas="text">' + html + '</div>';

                    Ext.each(opts.options, function (option, index, allItems) {
                        // console.log("printing each option", option);
                        var cls = ['option', (opts.multi ? 'check' : 'radio')];

                        if (option.correct) {
                            cls.push('correct');
                        }
                        if (option.answer) {
                            cls.push('selected');
                        } else {
                            // add answer parameter that is getting set when checking and unchecking answer
                            option.answer = false;
                        }
                        // added two custom attributes idx which is index of element (starting with 0) and type which can contain chech or radio
                        html += '<div class="' + cls.join(' ') + '" idx=' + index + ' type=' + (opts.multi ? 'check' : 'radio') + '>' + option.text + '</div>';
                    });



                    // console.log("printing html atm", html, opts);


                    // TODO - this is after end
                    content.innerHTML = html;
                    content = cmp.appendChild(content);

                    cmp = parentEl.dom.appendChild(cmp);

                    cmp._opts = opts;
                    cmp.type = opts.type;

                    extCmp = Ext.get(cmp);
                    extCmp._opts = opts;
                    extCmp.type = opts.type;




                    me.addComponentListeners(cmp);

                    return extCmp;


                }
            });


        }

        if (opts.type == me.cmpTypes.IMAGE && opts.src) {
            if(navigator.onLine){
                content.style.backgroundImage = 'url(' + opts.src + ')';
            }else{
                content.style.backgroundColor = 'powderblue';
                html = 'Image cannot be loaded - go online to view photo';
            }

        }


        // adding classes to surrounding div element of component
        content.classList.add('html-content');
        Ext.each(opts.cls, function (cls) {
            content.classList.add(cls);
        });




        content.innerHTML = html;
        content = cmp.appendChild(content);

        cmp = parentEl.dom.appendChild(cmp);

        cmp._opts = opts;
        cmp.type = opts.type;

        extCmp = Ext.get(cmp);
        extCmp._opts = opts;
        extCmp.type = opts.type;


        if (!me.previewing) {
            cmp._dragger = new Ext.drag.Source({
                element: extCmp,
                constrain: {
                    element: parentEl,
                    snap: {
                        x: snap,
                        y: snap
                    }
                },
                listeners: {
                    beforedragstart: function (component, info, event, eOpts) {
                        if (info.eventTarget.classList.contains('x-resizable-handle')) {
                            return false;
                        }
                    },
                    dragcancel: function (component, info, event, eOpts) {
                        console.log('dragcancel', arguments);
                    },
                    dragend: function (component, info, event, eOpts) {
                        console.log('dragend', arguments);
                    },
                    dragmove: function (component, info, event, eOpts) {
                        var pos = info.element.current,
                            x = pos.x - parentEl.getX(),
                            y = pos.y - parentEl.getY();

                        cmp._opts.x = x;
                        cmp._opts.y = y;
                        //             console.log(Ext.String.format('dragmove X: {0}, Y: {1}', x, y));
                    },
                    dragstart: function (component, info, event, eOpts) {
                        console.log('dragstart', arguments);
                    }
                }
            });

            cmp._resizer = Ext.create('Ext.create', 'Ext.resizer.Resizer', {
                target: extCmp,
                //pinned:true,
                minWidth: snap,
                minHeight: snap,
                heightIncrement: snap,
                widthIncrement: snap,
                preserveRatio: false,
                dynamic: true,
                transparent: false,
                handles: 'all', // shorthand for 'n s e w ne nw se sw'
                listeners: {

                    resize: function (component, width, height, e, eOpts) {
                        cmp.width = width;
                        cmp.height = height;
                        cmp._opts.width = width;
                        cmp._opts.height = height;
                        //console.log(Ext.String.format('W: {0}, H: {1}', width, height));

                    }
                }
            });
        }


        me.addComponentListeners(cmp);

        return extCmp;
    },

    editComponent: function(component) {
        var me = this,
            refs = me.getReferences();

        component = component || me._selectedComponent;
        if (component) {
            if ((component.type == me.cmpTypes.IMAGE) || (component.type == me.cmpTypes.VIDEO) || (component.type == me.cmpTypes.AUDIO) ){
                console.log("Cannot edit image, video or audio");
                return;
            }

            if (component.type == me.cmpTypes.SELECTION) {
                me.editSelection(component);
            }

            else {
                var wnd = me.getView().add({xtype: 'texteditor'});

                wnd.getController().show({
                    value: component.el.down('.html-content').dom.innerHTML,
                    callback: function (value) {
                        component.el.down('.html-content').dom.innerHTML = value;
                        component._opts.html = value;
                        me.saveSlideState();
                    },
                    scope: me
                });
            }
        }
    },

    duplicateComponent: function(component) {
        var opts = Ext.clone(component._opts);

        delete opts.x;
        delete opts.y;

        var cmp = this.insertComponent(opts);

        cmp.fireEvent('click');
    },

    deleteComponent: function(component) {
        var me = this,
            refs = this.getReferences();

        component = component || me._selectedComponent;

        if(component) {
            me._selectedComponent.destroy();
            me._selectedComponent = null;
            me.saveSlideState();
        }
    },

    insertTitle: function(value) {
        var me = this,
            cmp = me.insertComponent({
                type: me.cmpTypes.TITLE,
                cls: 'title',
                html: value || 'Title',
                height: 50
            });
         me.saveSlideState();

        // me.editComponent(cmp);
    },

    insertText: function(value) {
        var me = this,
            cmp = me.insertComponent({
                type: me.cmpTypes.TEXT,
                cls: 'text',
                html: value || 'Text',
                height: 425
            });
         me.saveSlideState();

        // me.editComponent(cmp);
    },

    insertImage: function() {
        var me = this,
            cmp = me.insertComponent({
                type: me.cmpTypes.IMAGE,
                cls: 'image',
                html: '',
                src: 'resources/images/example.jpg',
                height: 275,
            });
         me.saveSlideState();

    },

    insertSelection: function(opts) {
        this.editSelection(null, opts);

    },

    editSelection: function(component, opts) {
        console.log("printing selection in editSelection at begining", this.getCurrentSlide());

        opts = Ext.applyIf(opts || {}, {
            multi: false
        });

        var me = this,
            refs = me.getReferences(),
            state = component && component._opts,
            multi = state && state.multi || opts.multi,
            wnd = me.getView().add({ xtype: 'selectioneditor' });

        wnd.getController().show({
            text: state && state.html,
            options: state && state.options,
            multi: multi,
            callback: function(text, answers) {

                if(answers.length === 0) {
                    return 'Please specify at least one answer';
                }
                if(answers.filter(function(item) { return item.correct; }).length === 0) {
                    return 'Please mark at least one answer as correct';
                }
                if(!multi && answers.filter(function(item) { return item.correct; }).length > 1) {
                    return 'Only one correct answer is allowed for single selection';
                }

                /*console.log("printing selection in editSelection at callback",  selection);*/

                /*if(!me.getCurrentSlide()){
                     console.log("setting new current selection");
                     me.getReferences().treeSlides.setSelection(selection);
                 }*/




                // Testing selection insert Jernej Habjan 2018-07-16

                var store = me.getStore('QuestionsStoreSlides');

                // getting all correct answers
                var correctAnswersIds = []; // this array stores ids of correct answers, where ids are generated as sequence numbers

                for (var i = 0; i < answers.length; i++) {
                    var element = answers[i];
                    //console.log("printing each element", element);
                    if (element.correct === true){
                        correctAnswersIds.push(element.id); // adds sequence number of this question
                    }
                }

                // getting page id
                var refs = this.getReferences(),
                    selection = refs.treeSlides.getSelection()[0];


                var pageGuid = selection.data.id;
                var componentGuid = createGUID();


                var record = {
                    questionGuid : componentGuid,
                    pageId: pageGuid,
                    question: text,
                    answers:Ext.encode(answers),
                    correctValue: Ext.encode(correctAnswersIds),
                    fieldType: me.cmpTypes.SELECTION

                };
                console.log("adding new record to store:", record);


                store.add(record);
                record.phantom = true; // todo - this may be unnecessarry

                // after adding to database add component to view

                store.sync({
                    callback: function(){


                        if(component) {
                            var state = component._opts;

                            me.deleteComponent(component);
                            state.html = text;
                            state.options = answers;
                            state.questionGuid =  componentGuid;
                            component = me.insertComponent(state);

                            console.log("condition went into if");

                        }
                        else {

                            console.log("triggered inserting component selection");

                            console.log("printing current selection", me.getCurrentSlide());
                            component = me.insertComponent({
                                type: me.cmpTypes.SELECTION,
                                cls: 'selection',
                                html: text,
                                options: answers,
                                multi: multi,
                                questionGuid: componentGuid
                            });
                            console.log("condition went into else");

                        }
                        //console.log("printing new component", component._opts);
                        me.saveSlideState();



                    }
                });



            },
            scope: me
        });

    },

    round: function(value) {
        var snap = this._pageSetup.snap;

        return Math.round(value / snap) * snap;
    },

    ceil: function() {
        var snap = this._pageSetup.snap;

        return Math.ceil(value / snap) * snap;
    },

    syncState: function() {
        // this function is used to sync localstorage and database storage.
        // All data remains in localstorage at all times, but if user is online, content is synced with database


        // save current state to localstorage

        // if online
        // get all data from server and add it to store
        // get all data from localstorage and add it to store
        // sync store
        // set all this data to localstorage

        // if offline
        // current state is saved to localstorage, so do nothing



        // save state to offline storage - switch to indexdb at some point?




        var me = this,
            localStorageData = localStorage.getItem('mxp_elearning_slide'),
            treeStoreSlides = me.getStore('TreeStoreSlides');


        if (!navigator.onLine){
            console.log("You are offline - cannot sync with server");
            return;

        }

        var me = this,
            localStorageData = Ext.decode(localStorage.getItem('mxp_elearning_slide')),
            treeStoreSlides = me.getStore('TreeStoreSlides');

        // test load so i can get data to try viewing it in console - remove this later
        treeStoreSlides.load({

            callback: function(records, operation, success){
                //console.log("printing localstorage data", localStorageData);


                console.log("printing tree store slides data", treeStoreSlides.data);
                if(treeStoreSlides.data.length === 0){
                    // no return data, check if there are any locally saved slides
                    console.log("returned no slides from server");
                    if((localStorageData !== null) && localStorageData.slides){
                        console.log("we have locally saved slides, syncing with server");
                        me.updateServerStore();
                    }
                    // set initial data
                    me.setInitialSlide();

                    return;
                }



                // here we have valid return data from server, so we can update localstorage and sync localstorage back with server


                treeStoreSlides.data.items.forEach((o, i, a) => {
                    if (!a[i].data.children){
                        a[i].data.children = [];
                    }
                });


                if(!localStorageData){
                    console.log("no data yet in localstorage", treeStoreSlides.data, treeStoreSlides);
                    localStorageData = me.getCurrentState();
                    treeStoreSlides.data.items.forEach(function(entry){
                        localStorageData.slides.push(entry.data);
                    });
                    localStorage.setItem('mxp_elearning_slide', Ext.encode(localStorageData));
                    // set initial data
                    me.setInitialSlide();
                    return;
                }

                if(!localStorageData.slides){
                    console.log("no slides yet in localstorage");
                    // localstorage slides are empty - set recieved data from server to localstorage - even if it is empty
                    localStorageData.slides = Ext.encode(treeStoreSlides.data);
                    localStorage.setItem('mxp_elearning_slide', Ext.encode(localStorageData));
                    // set initial data
                    me.setInitialSlide();
                    return;
                }

                // here we have valid localstorage and may need syncing
                localStorageData.slides = Array.from(new Set(localStorageData.slides));
                localStorageData.slides.forEach((o, i, a) => {
                    if (!a[i].children){
                        a[i].children = [];
                    }
                });





                // Updating localstorage:
                for (var i =0; i < treeStoreSlides.data.items.length; i++){
                    var slide = treeStoreSlides.data.items[i];
                    //console.log("printing each slide data",slide.data);
                    // check if item is not yet in localstorage
                    //console.log("printing item id", localStorageData.slides, slide);
                    if(localStorageData.slides.some(item => item.id === slide.data.id)){

                    }else{
                        //console.log("adding new slide to localstorage");
                        localStorageData.slides.push(slide.data);
                    }
                }
                // setting modified data back to localstorage
                localStorage.mxp_elearning_slide = Ext.encode(localStorageData);

                // Updating server store:
                me.updateServerStore();


                // set initial data
                me.setInitialSlide();



            }
        });




        return;

        // Todo - Custom indexedDb database
        var proxy = Ext.create('Lib.data.proxy.IndexedDB',{
            model: 'Program',
            reader: 'json'
        });
        //proxy.setModel(component.getStore().getModel());
        component.getStore().setProxy(proxy);
        component.getStore().load();




    },

    insertAudio: function() {

        var me = this,
            cmp = me.insertComponent({
                type: me.cmpTypes.AUDIO,
                cls: 'audio',
                html: '<audio controls>  <source src="resources/audio/horse.mp3" type="audio/mpeg">Your browser does not support the audio element.</audio>',
                src: 'resources/audio/horse.mp3',
                height: 50,
            });
        console.log("inserting audio unsupported");
         me.saveSlideState();

    },

    insertVideo: function() {
        var me = this,
            cmp = me.insertComponent({
                type: me.cmpTypes.VIDEO,
                cls: 'video',
                html: '<video width="320" height="240" controls>  <source src="resources/videos/mov.mp4" type="video/mp4"> Your browser does not support the video tag.</video>',
                src: 'resources/videos/mov.mp4',
                height: 240,
            });
        console.log("inserting video unsupported");
         me.saveSlideState();

    },

    getNumSlides: function() {
        // Retrieves count of slides (sections don't count)

        var countSlides = 0;
        var data = localStorage.getItem('mxp_elearning_slide');
        if(data) {
            data = Ext.decode(data);
            if(data.slides) {
                data.slides.forEach(function (value) {
                    if(value.isSlide){
                        countSlides +=1;
                    }
                });
            }
        }
        return countSlides;
    },

    evaluate: function() {
        // returns [singleSelectionCorrect, singleSelectionQuestions, multipleSelectionScore, multipleSelectionScoreUsingNegative]
        // multipleSelectionScore -> if answer_correct -> answer_score += 1/num_answers
        //							 else: answer_score = (answer_score - 1/num_answers).clamp(0, num_answers)
        //multipleSelectionScoreUsingNegative -> dont clamp incorrectly answered
        Number.prototype.clamp = function (min, max) {
            return Math.min(Math.max(this, min), max);
        };

        // iterate through slides and questions and check score:
        var me = this,
            usingNegativeScore = false, // config variable which determines if each answer can have negative return points
            totalUserScore = 0;

        me.saveState(); // TODO - latest addition - is it necessary?

        var data = localStorage.getItem('mxp_elearning_slide');
        if (data) {
            data = Ext.decode(data);
            if (data.slides) {
                data.slides.forEach(function (value) {
                    if (value.isSlide) {
                        var questions = Ext.decode(value.content).components;
                        questions.forEach(function (question) {
                            totalUserScore += me.getScore(question, usingNegativeScore);
                            console.log("printing new user score", totalUserScore);
                        });
                    }
                });
                console.log("printing final user score:", totalUserScore);
            }
        }



    },

    getScore: function(question, usingNegativeScore) {

        var answerScore = 0;
        var correctAnswer;
        var usersAnswer;
        var _question = question.options;
        var questionNumAnswers = _question.length;

        if (question.multi) {
            // make a pre-pass counting num_correct_answers
            var numCorrectAnswers = 0;
            _question.forEach(function (option) {

                if (option.correct) {
                    numCorrectAnswers += 1;
                }
            });
            // go through all questions in this form

            _question.forEach(function (option) {
                usersAnswer = option.answer;
                correctAnswer = option.correct;
                if (usersAnswer == correctAnswer) {
                    if (correctAnswer === true) {
                        // if we checked correct answer - add percent of all correct answers to his score
                        answerScore += (1 / numCorrectAnswers);
                    }
                    // no else - we are not rewarding for not checking not-correct answers
                }
                else{
                    // we didnt click what is correct

                    if (correctAnswer === true) {
                        // if we clicked no but answer was yes, punish user by subtracting percent of all correct answers from his score
                        answerScore -= (1 / numCorrectAnswers);
                    }
                    else{
                        // if we clicked yes but answer was no, punish user by subtracting only percent of num answers
                        answerScore -= (1/ questionNumAnswers);
                    }
                }
            });

            // append score of this questionary to totalScore
            console.log("user score appended with", answerScore);
            if(!usingNegativeScore){
                // clamp between 0 and max
                answerScore = (answerScore).clamp(0, questionNumAnswers);
            }

        } else {
            // evaluate
            _question.forEach(function (option) {

                usersAnswer = option.answer;
                correctAnswer = option.correct;

                if ((correctAnswer === true) && (usersAnswer == correctAnswer)) {
                    answerScore = 1;
                }
                else {
                    if(usersAnswer == correctAnswer){
                        // this is not right answer but we checked right one

                        if(usingNegativeScore){
                            // returns -1 - is this too much?
                            answerScore = -1;
                        }
                        // else return 0
                    }
                }
            });
        }

        return answerScore;
    },

    saveState: function() {
        // sets current state to localstorage and calls update with server

        localStorage.setItem('mxp_elearning_slide', Ext.encode(this.getCurrentState()));
        // TODO - this may remain as comment as if syncing state,
        // we are retrieving data from server for no reason and possibly overwriting current state
        //this.syncState();

        this.updateServerStore();
    },

    updateServerStore: function() {
        // updates treestore using localstorage and syncs with server
        var me = this,
            localStorageData = Ext.decode(localStorage.getItem('mxp_elearning_slide')),
            treeStoreSlides = me.getStore('TreeStoreSlides');

        // Updating server store:
        // make slides unique
        localStorageData.slides = Array.from(new Set(localStorageData.slides));
        // setting data from localstorage to store

        // clear store so we might add all synced data from localstorage to sync with server (append child)
        treeStoreSlides.getRootNode().removeAll();

        // IMPORTANT! Use .appendChild when adding data to treestore for sync to work
        treeStoreSlides.getRootNode().appendChild(localStorageData.slides);
        // setting all records' phantom state to true
        for (var i = 0; i < treeStoreSlides.data.items.length; i++){
            var rec = treeStoreSlides.data.items[i];
            // IMPORTANT! rec.phantom must be set to true, othewise sync wont work, as "data isn't changed"
            rec.phantom = true;
        }
        // sync data back to server
        treeStoreSlides.sync();
    },

    setInitialSlide: function() {
        // this function is used to set slide after syncing with server or initially recieving data (from localstorage or server)
        var me = this,
            refs = me.getReferences();

        var currentSlide = me.getCurrentSlide();
        if(currentSlide){
            refs.treeSlides.setSelection(currentSlide);
            return;
        }
        // this part of code gets executed when there is no current selection yet


        // switch to first slide
        Ext.defer(function() {
            me.nextSlide();
        }, 100);

        me.setBackground(me._pageSetup.background);
        refs.panelContent.setWidth(me._pageSetup.width);
        refs.panelContent.setHeight(me._pageSetup.height);
    },

    close: function(owner, tool, event) {
        this.getView().up('#mainView').setActiveItem('gridPrograms');
    },

    onTreeViewDragDrop: function(treeviewdragdrop) {
        this.saveState();
    },

    onTreeSlidesSelect: function(rowmodel, record, index, eOpts) {
        // loading slide state for both sections and slides, because creating title every time caused sync with database
        this.loadSlideState(record);

        // if(record.isLeaf()) {
        //     this.loadSlideState(record);
        // }
        // else {
        //     this.clearSlidePanel();
        //
        //     // Todo -insert title is causing another sync with database
        //     this.insertTitle('Section ' + record.get('title'));
        // }



        return;
        // TODO - Jernej Habjan 2018-07-12
        // Trying to replace slide icon in treeview by rendered content

        var me = this,
            refs = me.getReferences();

        console.log("printign refs",refs.treeSlides);

        console.log("ext get", Ext.get(refs.treeSlides));

        // todo - check if there are any children - possible crash here
        console.log("printing children",refs.treeSlides.el.dom.children[0].children[1].children[0].children[1].children);


        // get all currently shown nodes in tree view - only parent of collapsed nodes is visible
        var treeView = refs.treeSlides.el.dom.children[0].children[1].children[0].children[1].children;
        for (var i=0, n=treeView.length; i < n; i++){

            var children = treeView[i].children[0].children[0].children[0].children[0].children;

            var slide = children[children.length - 2]; // slots before that occupy indents in tree view, slot after that is text



            console.log("printing all kids", treeView[i].children[0].children[0].children[0].children[0].children);
            console.log("printing slide", slide);


            console.log("printing slide class list", slide.classList);

            // uncomment this if to allow rendering on all tree nodes - and not only on slides
            if(slide.classList.contains("x-tree-icon-leaf")){ // check if it is slide
                slide.outerHTML = '<div role="presentation" class="  x-tree-icon"><img src="https://www.vaporfi.com.au/media/catalog/product/cache/34/thumbnail/600x600/9df78eab33525d08d6e5fb8d27136e95/v/z/vz_eliquid_juicy_red_apple.jpg" style="width:20px; height:20px;"></div>';

                // Todo - replace apple photo with rendered slide with scale of 20, 20


            }

        }

        // Part 2 - rendering slides in appropriate slots:


        // var data = localStorage.getItem('mxp_elearning_slide');
        // if(data) {
        //     data = Ext.decode(data);
        //     if(data.slides) {
        //         data.slides.forEach(function (value) {
        //             if(value.isSlide){
        //                 console.log("printing slide",value);
        //             }
        //         });
        //     }
        // }

        // Part 3 - slide html to canvas - http://html2canvas.hertzen.com/

        // document.body.innerHTML += '<div id="capture" style="padding: 10px; background: #f5da55">    <h4 style="color: #000; ">Hello world!</h4></div>';
        //
        //
        // html2canvas(document.querySelector("#capture")).then(canvas => {
        //     document.body.appendChild(canvas);
        // });



    },

    onTreeSlidesDeselect: function(rowmodel, record, index, eOpts) {
        //this.saveSlideState(record);
    },

    onEditSlidesBoxReady: function(component, width, height, eOpts) {
        var me = this,
            refs = me.getReferences();

        me._selectedComponent = null;
        me.previewing = false; // used for toggling event actions when previewing or not

        me._pageSetup = {
            snap: 25,
            width: 800,
            height: 600,
            headerHeight: 50,
            footerHeight: 50,
            padding: 50,
            background: null
        };

        me.cmpTypes = {
            HTML: 'html',
            TITLE: 'title',
            TEXT: 'text',
            IMAGE: 'image',
            AUDIO: 'audio',
            VIDEO: 'video',
            SELECTION: 'selection'
        };

        refs.panelContent.removeAll();
        refs.toolbarPreview.hide();

        // call sync state here and not save state, as we dont have anything to save yet



        if (navigator.onLine){
            me.syncState();
            // set initial data
            me.setInitialSlide();
        }
        else{
            // set localstorage data to tree store
            var me = this,
                localStorageData = Ext.decode(localStorage.getItem('mxp_elearning_slide')),
                treeStoreSlides = me.getStore('TreeStoreSlides');
            treeStoreSlides.setData(localStorageData.slides);


            // set initial data
            me.setInitialSlide();


        }



        component.el.on('click', function(e, t) {
            // hiding component tools if component itself (like bodyPanel, ImageComponent...) didn't stop click event to backpropagate
            me.hideComponentTools();
        });

        document.addEventListener("keydown", function onPress(event) {
            // console.log("Caller - onEditSlidesBoxReady", "body keydown", event.keyCode);
            var KEY_DELETE = 46;
            if(me._selectedComponent){
                if(event.keyCode === KEY_DELETE){
                    me._componentTools.getController().delete();
                }
            }
        });



        // create online / offline event listenere - when coming back online, we want to sync localstorage with database
        function connectionChange() {
            if (navigator.onLine){
                me.syncState();


                var currentSlide = me.getCurrentSlide();
                me.getReferences().treeSlides.setSelection(null);
                me.getReferences().treeSlides.setSelection(currentSlide); // retrigger current slide to update
                Ext.toast('Welcome back online! Content saved on server.');

            }else{
                Ext.toast('We went offline! Content is still saved locally. Reconnect to save content with server.');
            }
        }
        // Update the online status icon based on connectivity
        window.addEventListener('online',  connectionChange);
        window.addEventListener('offline', connectionChange);
    }

});
