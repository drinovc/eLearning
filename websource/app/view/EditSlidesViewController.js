/*
 * File: app/view/EditSlidesViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.3.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.5.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.5.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('eLearning.view.EditSlidesViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.editslides',

    load: function(opts) {
        opts = Ext.applyIf(opts || {}, {
            program: null
        });

        var me = this,
            refs = me.getReferences();

        refs.panelHeader.setTitle(opts.program.get('name'));

    },

    newSection: function() {
        console.log("creating new section" ,"TODO -leaf is here set to true, but it should be pulled from database if this section has any children");
        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides');

        var data = {
            id: createGUID(),
            sequence: null,
            title: 'New Section',
            content: null,
            expanded: false,
            children: [],

            //leaf: true, // TODO - debuging purposes
            category : me.ProgramPageCategoriesEnum.Chapter

        };

        var parentNode = /*refs.treeSlides.getSelection()[0] ||*/ store.getRoot();

        slide = parentNode.appendChild(data);


        refs.treeSlides.setSelection(slide);

        //me.saveSlideState(slide);

    },

    newSlide: function() {
        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides'),
            parentNode = refs.treeSlides.getSelection()[0] || store.getRoot(),
            slide,
            data = {
                id: createGUID(),
                // sequence: sequence,
                title: 'New Slide', // + sequence,
                content: null,
                expanded: true,
                leaf: true,
                isSlide : true,
                category : me.ProgramPageCategoriesEnum.Page
            };

        if(parentNode.isLeaf()) {
            parentNode = parentNode.parentNode;
        }

        slide = parentNode.appendChild(data);
        refs.treeSlides.setSelection(slide);

        me.saveSlideState(slide);
    },

    deleteSlide: function(slide) {
        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides');

        slide = slide || me.getCurrentSlide();

        if(slide) {
            console.log("printing current slide", slide);

            var nextSlideIdx = store.indexOf(slide) - 1,
                nextSlide = store.getAt(nextSlideIdx >= 0 ? nextSlideIdx : 1),
                components = (Ext.decode(slide.get('content') || '{}').components);

            if(components && components.length > 0) {
                Ext.Msg.confirm('Delete slide', 'Are you sure?', function(btn) {
                    if(btn == 'yes') {
                        if(slide.parentNode){
                            slide.parentNode.removeChild(slide);
                            me.saveState();
                            me.clearSlidePanel();
                            refs.treeSlides.setSelection(nextSlide);
                        }else{
                            console.error("Caller - EditSlides/deleteSlide", "No parent node exists", " printing slide:", slide);
                        }

                    }
                });
            }
            else {
                slide.parentNode.removeChild(slide);
                me.saveState();
                me.clearSlidePanel();
                refs.treeSlides.setSelection(nextSlide);

            }
        }
    },

    getCurrentSlide: function() {
        var me = this,
            refs = me.getReferences();

        return refs.treeSlides.getSelection()[0];
    },

    nextSlide: function() {
        // variable to recursively descend to first slide - if its set to false, we also visit sections
        var REC_TO_SLIDE = true;

        // if (REC_TO_SLIDE &&  this.getNumSlides() < 2){
        //     // there is 1 or 0 slides and recursion is set to true - which means we cannot visit sections so return
        //     return;
        // }

        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides'),
            slide = me.getCurrentSlide(),
            nextSlideIdx = store.indexOf(slide) + 1,
            nextSlide = store.getAt(nextSlideIdx);
        if(nextSlide) {

            refs.treeSlides.setSelection(nextSlide);
            if (nextSlide.data.leaf === false){



                me.nextSlide();

                if(REC_TO_SLIDE){
                    // recursively iterate to leaf slide through section
                    if (this.getNumSlides() === 0){
                        console.log("cannot switch recursively to next slide", "no slides exist");
                        return;
                    }
                    if (me.getCurrentSlide().data.leaf === false){
                        me.prevSlide();
                    }
                }



            }
        }


    },

    prevSlide: function() {


        // variable to recursively ascend to first remaining slide - if its set to false, we also visit sections
        var REC_TO_SLIDE = true;

        // if (REC_TO_SLIDE &&  this.getNumSlides() < 2){
        //     // there is 1 or 0 slides and recursion is set to true - which means we cannot visit sections so return
        //     return;
        // }

        var me = this,
            refs = me.getReferences(),
            store = me.getStore('TreeStoreSlides'),
            slide = me.getCurrentSlide(),
            prevSlideIdx = store.indexOf(slide) - 1,
            prevSlide = store.getAt(prevSlideIdx);


        if(prevSlide) {
            refs.treeSlides.setSelection(prevSlide);
            if (prevSlide.data.leaf === false){

                me.prevSlide();

                if(REC_TO_SLIDE){
                    // recursively iterate to leaf slide through section
                    if (this.getNumSlides() === 0){
                        console.log("cannot switch recursively to prev slide", "no slides exist");
                        return;
                    }


                    if (me.getCurrentSlide().data.leaf === false){
                        me.nextSlide();
                    }

                }


            }



        }
    },

    setBackground: function(src) {
        var me = this,
            refs = me.getReferences();

        me._pageSetup.background = src;

        if(src) {
            Ext.getCmp('panelContent').setStyle('background', 'url(' + src + ')');
        }
        else {
            Ext.getCmp('panelContent').setStyle('background', null);
        }
    },

    togglePreview: function(preview) {
        var me = this,
            refs = me.getReferences();

        me.previewing = preview; // setting current previewing state

        //refs.panelMenu.setVisible(!preview); // commented so navigation tree is visible even when solving quiz
        refs.toolbarEdit.setVisible(!preview);
        refs.toolbarPreview.setVisible(!!preview);
        refs.panelContent[preview ? 'removeCls' : 'addCls']('edit');
        refs.panelContent[preview ? 'addCls' : 'removeCls']('preview');

        refs.panelSlide.setMargin(preview ? '10' : '10 10 10 0');


        // retarget this slide - this redraws current slide without dragger and sizer
        refs.treeSlides.setSelection(null);
        refs.treeSlides.setSelection(me.getCurrentSlide());


        if(preview) {
            me.saveSlideState(me.getCurrentSlide());
            var firstSlide = refs.treeSlides.store.getAt(0);
            refs.treeSlides.setSelection(firstSlide);
            // on panel toggle - drop down the sections to first actual slide
            if (firstSlide.data.leaf === false){
                me.nextSlide();
            }
        }else{
            // we / timer toggled preview off - validate forms and submit


            me.evaluate();


        }






        // Switching countdown timer when toggling preview - preview automatically closes when timer turns to 0
        // TODO - is this secure - should't countdown occur on server side - is it?
        var counter = 1000;

        var taskPoll = {
            run: function(){
                counter -= 1;
                if( counter < 1 ){
                    Ext.TaskManager.stop(taskPoll);

                    me.togglePreview();
                } else {
                    var timerCountdownText = refs.toolbarPreview.el.down('#timerCountdown');
                    timerCountdownText.dom.innerHTML = "00:" + counter.toString();
                }
            },
            interval: 1000
        };

        if(preview) {
            Ext.TaskManager.start(taskPoll);

        }else{
            Ext.TaskManager.stop(taskPoll);

        }
    },

    getFreePosition: function() {
        var me = this,
            refs = me.getReferences(),
            snap = me._pageSetup.snap,
            pos = {
                x: snap*2,
                y: snap*2,
                width: me.round(refs.panelContent.el.getWidth() - 2*snap*2),
                height: snap*2
            };

        Ext.each(refs.panelContent.el.query('.html-component'), function(component) {
            pos.y = me.round(Math.max(pos.y, component.y + component.height + snap));
        });

        return pos;
    },

    getSlideComponents: function() {
        return this.getReferences().panelContent.el.query('.html-component');
    },

    getCurrentState: function() {
        var me = this,
            refs = me.getReferences(),
            slides = Ext.clone(Ext.pluck(refs.treeSlides.store.getRange(), 'data')).map(function(node) { return cleanTreeNodeData(node); });
        data = {
                slides: slides,
                pageSetup: me._pageSetup
            };

        return data;
    },

    saveSlideState: function(slide) {
        var me = this,
            refs = me.getReferences(),
            content = {
                components: []
            };

        slide = slide || me.getCurrentSlide();

        if(slide) {

            Ext.each(me.getSlideComponents(), function(component) {
                content.components.push(component._opts);
            });

            slide.set('content', Ext.encode(content));

            me.saveState();


        }
    },

    loadSlideState: function(slide) {
        var me = this,
            refs = me.getReferences(),
            parentEl = refs.panelContent.el.down('#html-slide');

        me.clearSlidePanel();

        if(slide) {
            var content = Ext.decode(slide.get('content') || '{}');

            Ext.each(content.components, function(component) {
                this.insertComponent(component);
            }, this);

            me._selectedComponent = null;
        }
    },

    clearSlidePanel: function() {
        var me = this,
            refs = me.getReferences(),
            parentEl = refs.panelContent.el.down('#html-slide');

        me.hideComponentTools();

        Ext.each(parentEl.query('.html-component'), function(component) {
            parentEl.removeChild(component);
        }, this);
    },

    addComponentListeners: function(item) {
        var me = this,
        item = Ext.get(item);

        item.on('click', function(e, t) {
            if(e.stopPropagation){
                e.stopPropagation();
            }


            var prevItem = me._selectedComponent;

            if(prevItem) {
                me._selectedComponent.removeCls('selected');
                if(me._tools) {
                    me._tools = null;
                }

                // if(prevItem == item) {
                //     me.hideComponentTools();
                //     me._selectedComponent = null;
                //     return;
                // }
            }
            if(!me.previewing){
                // not previewing - show edit tools
                me._selectedComponent = item;
                me._selectedComponent.addCls('selected');
                me.showComponentTools(item);
            }else{
                // previewing

                // Handle checkboxes and radio buttons
                var SELECTED_VALUE = t.getAttribute('idx'); // idx have checboxes and radio buttons
                if (SELECTED_VALUE){
                    // getting array from html collection
                    var answers = Array.from(item.dom.children[0].children); // to change dom style
                    var answers_js =  item.el._opts.options; // to update javascript object and set answer to true/false


                    answers.shift(); // remove first text item (text) - all other are radio / check buttons

                    var type = answers[0].getAttribute('type');

                    switch(type) {
                    case 'radio':
                        for (var i = 0, len = answers.length; i < len; i++) {
                            answers[i].classList.remove('selected');
                            answers_js[i].answer = false;
                        }
                        answers[SELECTED_VALUE].classList.add('selected');
                        answers_js[SELECTED_VALUE].answer = true;
                        break;
                    case 'check':
                        answers[SELECTED_VALUE].classList.toggle("selected");
                        answers_js[SELECTED_VALUE].answer = !answers_js[SELECTED_VALUE].answer;
                        break;
                    default:
                        console.error("Caller - addComponentListeners", "Unsupported component type" ,type);
                    }
                    me.saveState();
                }


            }
        });

        // if(!me.previewing){ - is in each of these 4 functions which checks for condition when event is fired - this is usefull
        // when switching back and forth from preview and remaining on same slide

        item.on('dblclick', function(e, t) {
            if(!me.previewing){
                me.editComponent(item);
            }
        });

        item.on('_edit', function(e, t) {
            if(!me.previewing){
                me.editComponent(item);
            }
        });

        item.on('_duplicate', function(e, t) {
            if(!me.previewing){
                me.duplicateComponent(item);
            }
        });

        item.on('_delete', function(e, t) {
            if(!me.previewing){
                me.deleteComponent(item);
                me.hideComponentTools(item);
            }
        });

    },

    showComponentTools: function(component) {
        var me = this;

        if(!me._componentTools) {
            me._componentTools = me.getView().add({ xtype: 'edittools' });
        }
        me._componentTools.getController().show({ component: component });
    },

    hideComponentTools: function(component) {
        var me = this;

        if(!me._componentTools) {
            me._componentTools = me.getView().add({ xtype: 'edittools' });
        }
        me._componentTools.close();

    },

    insertComponent: function(opts) {
        opts = Ext.applyIf(opts || {}, {
            type: null,
            height: null,
            width: null,
            x: null,
            y: null,
            html: '',
            options: [],
            multi: false,
            src: '',
            cls: null,
            style: null
        });

        if (!opts.type) {
            Ext.Msg.alert('Error', 'No component type');
        }

        if (opts.cls && typeof opts.cls == "string") {
            opts.cls = [opts.cls];
        }

        var me = this,
            refs = me.getReferences(),
            pos = me.getFreePosition(),
            snap = me._pageSetup.snap,
            parentEl = refs.panelContent.el.down('#html-slide'),
            cmp = document.createElement('div');

        if (!me.getCurrentSlide()) {
            me.newSlide();
        }

        // set size
        // if(opts.type == 'image' && opts.src) {
        //     // determine image size
        //     var img = new Image();

        //     img.onload = function() {
        //         cmp.width = me.round(isNull(opts.width, img.width));
        //         cmp.height = me.round(isNull(opts.height, img.height));
        //         cmp.style.width = cmp.width + 'px';
        //         cmp.style.height = cmp.height + 'px';
        //     };
        //     img.src = opts.src;

        //     // show image as background
        //      cmp.style.backgroundImage = 'url(' + opts.src + ')';
        // }
        // else {
        cmp.width = opts.width = me.round(isNull(opts.width, pos.width));
        cmp.height = opts.height = me.round(isNull(opts.height, pos.height));
        cmp.style.width = cmp.width + 'px';
        cmp.style.height = cmp.height + 'px';
        // }

        // set classes
        cmp.classList.add('html-component');

        // set position
        cmp.x = opts.x = isNull(opts.x, pos.x);
        cmp.y = opts.y = isNull(opts.y, pos.y);

        cmp.style.left = cmp.x + 'px';
        cmp.style.top = cmp.y + 'px';

        // set content
        var content = document.createElement('div');
        var html = opts.html;

        content.classList.add('html-content');
        Ext.each(opts.cls, function (cls) {
            content.classList.add(cls);
        });

        if (opts.type == me.cmpTypes.SELECTION && opts.options) {

            html = '<div clas="text">' + html + '</div>';

            Ext.each(opts.options, function (option, index, allItems) {
                var cls = ['option', (opts.multi ? 'check' : 'radio')];

                if (option.correct) {
                    cls.push('correct');
                }
                if (option.answer) {
                    cls.push('selected');
                } else {
                    // add answer parameter that is getting set when checking and unchecking answer
                    option.answer = false;
                }
                // added two custom attributes idx which is index of element (starting with 0) and type which can contain chech or radio
                html += '<div class="' + cls.join(' ') + '" idx=' + index + ' type=' + (opts.multi ? 'check' : 'radio') + '>' + option.text + '</div>';
            });
        }

        if (opts.type == me.cmpTypes.IMAGE && opts.src) {
            content.style.backgroundImage = 'url(' + opts.src + ')';
        }
        content.innerHTML = html;
        content = cmp.appendChild(content);

        cmp = parentEl.dom.appendChild(cmp);

        cmp._opts = opts;
        cmp.type = opts.type;

        extCmp = Ext.get(cmp);
        extCmp._opts = opts;
        extCmp.type = opts.type;


        if (!me.previewing) {


            cmp._dragger = new Ext.drag.Source({
                element: extCmp,
                constrain: {
                    element: parentEl,
                    snap: {
                        x: snap,
                        y: snap
                    }
                },
                listeners: {
                    beforedragstart: function (component, info, event, eOpts) {
                        if (info.eventTarget.classList.contains('x-resizable-handle')) {
                            return false;
                        }
                    },
                    dragcancel: function (component, info, event, eOpts) {
                        console.log('dragcancel', arguments);
                    },
                    dragend: function (component, info, event, eOpts) {
                        console.log('dragend', arguments);
                    },
                    dragmove: function (component, info, event, eOpts) {
                        var pos = info.element.current,
                            x = pos.x - parentEl.getX(),
                            y = pos.y - parentEl.getY();

                        cmp._opts.x = x;
                        cmp._opts.y = y;
                        //             console.log(Ext.String.format('dragmove X: {0}, Y: {1}', x, y));
                    },
                    dragstart: function (component, info, event, eOpts) {
                        console.log('dragstart', arguments);
                    }
                }
            });

            cmp._resizer = Ext.create('Ext.create', 'Ext.resizer.Resizer', {
                target: extCmp,
                //pinned:true,
                minWidth: snap,
                minHeight: snap,
                heightIncrement: snap,
                widthIncrement: snap,
                preserveRatio: false,
                dynamic: true,
                transparent: false,
                handles: 'all', // shorthand for 'n s e w ne nw se sw'
                listeners: {

                    resize: function (component, width, height, e, eOpts) {
                        cmp.width = width;
                        cmp.height = height;
                        cmp._opts.width = width;
                        cmp._opts.height = height;
                        //console.log(Ext.String.format('W: {0}, H: {1}', width, height));

                    }
                }
            });
        }


        me.addComponentListeners(cmp);
        me.saveSlideState();

        return extCmp;
    },

    editComponent: function(component) {
        var me = this,
            refs = me.getReferences();

        component = component || me._selectedComponent;
        if (component) {
            if ((component.type == me.cmpTypes.IMAGE) || (component.type == me.cmpTypes.VIDEO) || (component.type == me.cmpTypes.AUDIO) ){
                console.log("Cannot edit image, video or audio");
                return;
            }

            if (component.type == me.cmpTypes.SELECTION) {
                me.editSelection(component);
            }

            else {
                var wnd = me.getView().add({xtype: 'texteditor'});

                wnd.getController().show({
                    value: component.el.down('.html-content').dom.innerHTML,
                    callback: function (value) {
                        component.el.down('.html-content').dom.innerHTML = value;
                        component._opts.html = value;
                        me.saveSlideState();
                    },
                    scope: me
                });
            }
        }
    },

    duplicateComponent: function(component) {
        var opts = Ext.clone(component._opts);

        delete opts.x;
        delete opts.y;

        var cmp = this.insertComponent(opts);

        console.log("Caller - duplicateComponent", "printing opts", opts, "printing new insertec comp", cmp);


        cmp.fireEvent('click');
    },

    deleteComponent: function(component) {
        var me = this,
            refs = this.getReferences();

        component = component || me._selectedComponent;

        if(component) {
            me._selectedComponent.destroy();
            me._selectedComponent = null;
            me.saveSlideState();
        }
    },

    insertTitle: function(value) {
        var me = this,
            cmp = me.insertComponent({
                type: me.cmpTypes.TITLE,
                cls: 'title',
                html: value || 'Title',
                height: 50
            });

        // me.editComponent(cmp);
    },

    insertText: function(value) {
        var me = this,
            cmp = me.insertComponent({
                type: me.cmpTypes.TEXT,
                cls: 'text',
                html: value || 'Text',
                height: 425
            });

        // me.editComponent(cmp);
    },

    insertImage: function() {
        var me = this,
            cmp = me.insertComponent({
                type: me.cmpTypes.IMAGE,
                cls: 'image',
                html: '',
                src: 'resources/images/example.jpg',
                height: 275,
            });
    },

    insertSelection: function(opts) {
        this.editSelection(null, opts);
    },

    editSelection: function(component, opts) {
        opts = Ext.applyIf(opts || {}, {
            multi: false
        });

        var me = this,
            refs = me.getReferences(),
            state = component && component._opts,
            multi = state && state.multi || opts.multi,
            wnd = me.getView().add({ xtype: 'selectioneditor' });

        wnd.getController().show({
            text: state && state.html,
            options: state && state.options,
            multi: multi,
            callback: function(text, answers) {

                if(answers.length === 0) {
                    return 'Please specify at least one answer';
                }
                if(answers.filter(function(item) { return item.correct; }).length === 0) {
                    return 'Please mark at least one answer as correct';
                }
                if(!multi && answers.filter(function(item) { return item.correct; }).length > 1) {
                    return 'Only one correct answer is allowed for single selection';
                }

                if(component) {
                    var state = component._opts;

                    me.deleteComponent(component);
                    state.html = text;
                    state.options = answers;

                    component = me.insertComponent(state);
                }
                else {
                    component = me.insertComponent({
                        type: me.cmpTypes.SELECTION,
                        cls: 'selection',
                        html: text,
                        options: answers,
                        multi: multi,
                        height: 100
                    });
                }

            },
            scope: me
        });
    },

    round: function(value) {
        var snap = this._pageSetup.snap;

        return Math.round(value / snap) * snap;
    },

    ceil: function() {
        var snap = this._pageSetup.snap;

        return Math.ceil(value / snap) * snap;
    },

    saveState: function() {
          // save state to offline storage - switch to indexdb at some point?
            localStorage.setItem('mxp_elearning_slide', Ext.encode(this.getCurrentState()));






        // Testing connecting delphi Programs module to TreeStoreSlides - Jernej Habjan 2018-07-12

        store = this.getStore('TreeStoreSlides');
        store.sync(
        {
            callback: function(){

                // Enable button
                console.log("TODO - enabling button back on sync callback");

                // cRegisterSave is a button id


                // IF the button is Extjs component then use
        //
                // Ext.getCmp('btnAdd').disable();
                // If it is not Ext js Component then use
        //
                // Ext.get('btnAdd').setDisabled(true);
                // I hope this will help.

            },
            success: function(){
                console.log("success callback");
            }
        });



    },

    insertAudio: function() {

        var me = this,
            cmp = me.insertComponent({
                type: me.cmpTypes.AUDIO,
                cls: 'audio',
                html: '<audio controls>  <source src="resources/audio/horse.mp3" type="audio/mpeg">Your browser does not support the audio element.</audio>',
                src: 'resources/audio/horse.mp3',
                height: 50,
            });
        console.log("inserting audio unsupported");

    },

    insertVideo: function() {
        var me = this,
            cmp = me.insertComponent({
                type: me.cmpTypes.VIDEO,
                cls: 'video',
                html: '<video width="320" height="240" controls>  <source src="resources/videos/mov.mp4" type="video/mp4"> Your browser does not support the video tag.</video>',
                src: 'resources/videos/mov.mp4',
                height: 240,
            });
        console.log("inserting video unsupported");
    },

    getNumSlides: function() {
        // Retrieves count of slides (sections don't count)

        var countSlides = 0;
        var data = localStorage.getItem('mxp_elearning_slide');
        if(data) {
            data = Ext.decode(data);
            if(data.slides) {
                data.slides.forEach(function (value) {
                    if(value.isSlide){
                        countSlides +=1;
                    }
                });
            }
        }
        return countSlides;
    },

    evaluate: function() {
        // returns [singleSelectionCorrect, singleSelectionQuestions, multipleSelectionScore, multipleSelectionScoreUsingNegative]
        // multipleSelectionScore -> if answer_correct -> answer_score += 1/num_answers
        //							 else: answer_score = (answer_score - 1/num_answers).clamp(0, num_answers)
        //multipleSelectionScoreUsingNegative -> dont clamp incorrectly answered
        Number.prototype.clamp = function (min, max) {
            return Math.min(Math.max(this, min), max);
        };

        // iterate through slides and questions and check score:
        var me = this,
            usingNegativeScore = false, // config variable which determines if each answer can have negative return points
            totalUserScore = 0;

        me.saveState(); // TODO - latest addition - is it necessary?

        var data = localStorage.getItem('mxp_elearning_slide');
        if (data) {
            data = Ext.decode(data);
            if (data.slides) {
                data.slides.forEach(function (value) {
                    if (value.isSlide) {
                        var questions = Ext.decode(value.content).components;
                        questions.forEach(function (question) {
                            totalUserScore += me.getScore(question, usingNegativeScore);
                            console.log("printing new user score", totalUserScore);
                        });
                    }
                });
                console.log("printing final user score:", totalUserScore);
            }
        }



    },

    getScore: function(question, usingNegativeScore) {

        var answerScore = 0;
        var correctAnswer;
        var usersAnswer;
        var _question = question.options;
        var questionNumAnswers = _question.length;

        if (question.multi) {
            // make a pre-pass counting num_correct_answers
            var numCorrectAnswers = 0;
            _question.forEach(function (option) {

                if (option.correct) {
                    numCorrectAnswers += 1;
                }
            });
            // go through all questions in this form

            _question.forEach(function (option) {
                usersAnswer = option.answer;
                correctAnswer = option.correct;
                if (usersAnswer == correctAnswer) {
                    if (correctAnswer === true) {
                        // if we checked correct answer - add percent of all correct answers to his score
                        answerScore += (1 / numCorrectAnswers);
                    }
                    // no else - we are not rewarding for not checking not-correct answers
                }
                else{
                    // we didnt click what is correct

                    if (correctAnswer === true) {
                        // if we clicked no but answer was yes, punish user by subtracting percent of all correct answers from his score
                        answerScore -= (1 / numCorrectAnswers);
                    }
                    else{
                        // if we clicked yes but answer was no, punish user by subtracting only percent of num answers
                        answerScore -= (1/ questionNumAnswers);
                    }
                }
            });

            // append score of this questionary to totalScore
            console.log("user score appended with", answerScore);
            if(!usingNegativeScore){
                // clamp between 0 and max
                answerScore = (answerScore).clamp(0, questionNumAnswers);
            }

        } else {
            // evaluate
            _question.forEach(function (option) {

                usersAnswer = option.answer;
                correctAnswer = option.correct;

                if ((correctAnswer === true) && (usersAnswer == correctAnswer)) {
                    answerScore = 1;
                }
                else {
                    if(usersAnswer == correctAnswer){
                        // this is not right answer but we checked right one

                        if(usingNegativeScore){
                            // returns -1 - is this too much?
                            answerScore = -1;
                        }
                        // else return 0
                    }
                }
            });
        }

        return answerScore;
    },

    close: function(owner, tool, event) {
        this.getView().up('#mainView').setActiveItem('gridPrograms');
    },

    onTreeViewDragDrop: function(treeviewdragdrop) {
        this.saveState();
    },

    onTreeSlidesSelect: function(rowmodel, record, index, eOpts) {





        if(record.isLeaf()) {
            this.loadSlideState(record);
        }
        else {
            this.clearSlidePanel();
            this.insertTitle('Section ' + record.get('title'));
        }

        return;
        // TODO - Jernej Habjan 2018-07-12
        // Trying to replace slide icon in treeview by rendered content

        var me = this,
            refs = me.getReferences();

        console.log("printign refs",refs.treeSlides);

        console.log("ext get", Ext.get(refs.treeSlides));

        // todo - check if there are any children - possible crash here
        console.log("printign children",refs.treeSlides.el.dom.children[0].children[1].children[0].children[1].children);


        // get all currently shown nodes in tree view - only parent of collapsed nodes is visible
        var treeView = refs.treeSlides.el.dom.children[0].children[1].children[0].children[1].children;
        for (var i=0, n=treeView.length; i < n; i++){

            var children = treeView[i].children[0].children[0].children[0].children[0].children;

            var slide = children[children.length - 2]; // slots before that occupy indents in tree view, slot after that is text



            console.log("printing all kids", treeView[i].children[0].children[0].children[0].children[0].children);
            console.log("printing slide", slide);


            console.log("printing slide class list", slide.classList);

            // uncomment this if to allow rendering on all tree nodes - and not only on slides
            if(slide.classList.contains("x-tree-icon-leaf")){ // check if it is slide
                slide.outerHTML = '<div role="presentation" class="  x-tree-icon"><img src="https://www.vaporfi.com.au/media/catalog/product/cache/34/thumbnail/600x600/9df78eab33525d08d6e5fb8d27136e95/v/z/vz_eliquid_juicy_red_apple.jpg" style="width:20px; height:20px;"></div>';

                // Todo - replace apple photo with rendered slide with scale of 20, 20


            }

        }

        // Part 2 - rendering slides in appropriate slots:


        // var data = localStorage.getItem('mxp_elearning_slide');
        // if(data) {
        //     data = Ext.decode(data);
        //     if(data.slides) {
        //         data.slides.forEach(function (value) {
        //             if(value.isSlide){
        //                 console.log("printing slide",value);
        //             }
        //         });
        //     }
        // }

        // Part 3 - slide html to canvas - http://html2canvas.hertzen.com/

        // document.body.innerHTML += '<div id="capture" style="padding: 10px; background: #f5da55">    <h4 style="color: #000; ">Hello world!</h4></div>';
        //
        //
        // html2canvas(document.querySelector("#capture")).then(canvas => {
        //     document.body.appendChild(canvas);
        // });



    },

    onTreeSlidesDeselect: function(rowmodel, record, index, eOpts) {
        this.saveSlideState(record);
    },

    onEditSlidesBoxReady: function(component, width, height, eOpts) {
        var me = this,
            refs = me.getReferences();

        // Getting ProgramPageCategories into enum where key is text ('Chapter', 'Page') and value is id (1, 2)
        me.ProgramPageCategoriesEnum = {};

        console.log("printing program categories",App.lookups.ProgramPageCategories);
        App.lookups.ProgramPageCategories.forEach((obj)=>{
            me.ProgramPageCategoriesEnum[obj.text] = obj.id;
        });
        Object.freeze(me.ProgramPageCategoriesEnum);




        me._selectedComponent = null;
        me.previewing = false; // used for toggling event actions when previewing or not


        me._pageSetup = {
            snap: 25,
            width: 800,
            height: 600,
            headerHeight: 50,
            footerHeight: 50,
            padding: 50,
            background: null
        };

        me.cmpTypes = {
            HTML: 'html',
            TITLE: 'title',
            TEXT: 'text',
            IMAGE: 'image',
            AUDIO: 'audio',
            VIDEO: 'video',
            SELECTION: 'selection'
        };

        refs.panelContent.removeAll();
        refs.toolbarPreview.hide();

        // load state from offline storage - switch to indexdb at some point?
        var data = localStorage.getItem('mxp_elearning_slide');

        if(data) {
            data = Ext.decode(data);
            if(data.pageSetup) {

                me._pageSetup = Ext.applyIf(data.pageSetup, me._pageSetup);
            }
            if(data.slides) {
                console.log("printing slides on page load", data.slides);

                //replace empty folders' children category 'undefined' with []
                data.slides.forEach((o, i, a) => {
                    if (!a[i].children){
                        a[i].children = [];
                    }
                });

                // if (data.slides[0].rootId === 'root'){ data.slides.shift(); }

                // TODO - Jernej Habjan - commented below line because TreeStoreSlides doesn't have memory proxy but rest proxy


                //me.getStore('TreeStoreSlides').getProxy().setData(data.slides);

                // TODO - Jernej Habjan - added data
                me.getStore('TreeStoreSlides').add(data.slides);

                console.log("calling sync on box ready after adding data", data.slides);
                me.getStore('TreeStoreSlides').sync(
                {
                    callback: function(){
                        console.log("Successfully added slides after being offline");
                    }
                });





                Ext.defer(function() {
                    me.nextSlide();
                }, 100);
            }
        }



        var store = me.getStore('TreeStoreSlides');
        store.load(

        {

            success : function(bb) { console.log("printing params", "store load success",bb); },
            failure : function(bb) { console.log("printing params", "store load failure",bb); },
            callback : function(bb) {console.log("printing params", "store load callback", bb); }
        }
        );



        console.log("called store load");






        me.setBackground(me._pageSetup.background);
        refs.panelContent.setWidth(me._pageSetup.width);
        refs.panelContent.setHeight(me._pageSetup.height);


        component.el.on('click', function(e, t) {
            // hiding component tools if component itself (like bodyPanel, ImageComponent...) didn't stop click event to backpropagate
            me.hideComponentTools();

        });


        document.addEventListener("keydown", function onPress(event) {
            console.log("Caller - onEditSlidesBoxReady", "body keydown", event.keyCode);
            var KEY_DELETE = 46;
            if(me._selectedComponent){
                if(event.keyCode === KEY_DELETE){
                    me._componentTools.getController().delete();
                }
            }

        });

    }

});
