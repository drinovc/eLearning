/*
 * File: app/view/EditSlidesViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.3.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.5.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.5.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('eLearning.view.EditSlidesViewController', {
	extend: 'Ext.app.ViewController',
	alias: 'controller.editslides',

	load: function(opts) {

		var me = this,
			refs = me.getReferences();



		opts = Ext.applyIf(opts || {}, {
			program: null
		});


		me.programData = opts.program.data; // create variable of this program that can be accessed from anywhere in this controller
		me.programId = opts.program.id; //


		if(opts.program.get){
			refs.panelHeader.setTitle(opts.program.get('name'));
		}
		else{
			// this gets called if we clicked editSlides button in main view
			refs.panelHeader.setTitle('Test title in debug mode');
		}
		// clear old panel if there is no slides on this program yet, so content from previous program doesn't remain on this one
		this.clearSlidePanel();
		me.allComponents = []; // clear old components - this array is used to store all ext components of this slide
		me._selectedComponents = [];

		// call sync state here and not save state, as we dont have anything to save yet
		var me = this,
			localStorageData = Ext.decode(localStorage.getItem('mxp_elearning')),
			treeStoreSlides = me.getStore('TreeStoreSlides'),
			questionsStoreSlides = me.getStore('QuestionsStoreSlides'),
			personAnswersStore = me.getStore('PersonAnswers');

		// init subfolders it they are not yet
		if(!localStorageData[me.programId].slides){localStorageData[me.programId].slides = {};}
		if(!localStorageData[me.programId].questions){localStorageData[me.programId].questions = {};}
		if(!localStorageData[me.programId].answers){localStorageData[me.programId].answers = {};}
		localStorage.setItem('mxp_elearning', Ext.encode(localStorageData)); // initializes localstorage if it is empty, otherwise overwrites it with same content


		// loaded latest person program so we can see if we can resume current program - color button to indicate that personProgram is still active

		var me = this,
			refs = me.getReferences(),
			personProgramsStore = me.getStore('PersonPrograms'),
			personAnswersStore = me.getStore('PersonAnswers');
		var TEST_PERSON_ID = 10000112;

		// reset button to default
		var previewButton = Ext.getCmp('btnPreview');
		previewButton.removeCls('active-program');
		previewButton.setText('Preview');

		if(me.programData.validTo < new Date()){
			Ext.toast("Program is not valid anymore!");
			Ext.get('btnPreview').disable();
			previewButton.setText('Program Not Valid');
			return;
		}

		if (navigator.onLine){
			var syncAnswersCallback = function(){
				me.saveState(); // save ALL data that is after all initial data syncs to localstorage
				// set initial data
				me.setInitialSlide();
			};





			personProgramsStore.load({
				params:{
					personId: TEST_PERSON_ID,
					programId: me.programId
				},
				callback:function(record){
					if(record && record.length > 0){
						me.currentPersonProgram = record[0].data;
						if(me.currentPersonProgram.attempt >= me.programData.maxAttemptsTrainingMode + me.programData.maxAttemptsScoreMode){
							// Cannot attempt any more tries... returning
							Ext.toast("No more attempts allowed!");
							return;
						}
						// here we can read the records id to use in posting answers
						// add completion time minutes to initial programStarted time
						var endTime = new Date(new Date(me.currentPersonProgram.programStarted).getTime() +
											   me.programData.completionTime * 60000); // completion time in database is in minutes
						var remainingMS = endTime.getTime() - new Date().getTime();
						if(remainingMS > 0 && (me.currentPersonProgram.programStatusId == App.ProgramStatuses["In Progress"] ||
											   me.currentPersonProgram.programStatusId == App.ProgramStatuses.Repeat)){
							previewButton.addCls('active-program');
							previewButton.setText('Resume preview');
						}
					}

					me.serverSync(syncAnswersCallback);


				}
			});






		}else{
			// set localstorage data to tree store

			treeStoreSlides.setData(localStorageData.slides);
			questionsStoreSlides.setData(localStorageData.questions);
			personAnswersStore.setData(localStorageData.answers);
			if(localStorageData.pageSetup){
				me._pageSetup = localStorageData.pageSetup;
			}


			// set initial data
			me.setInitialSlide();
		}




	},

	newSection: function() {
		//creating new section" ,"TODO -leaf is here set to true, but it should be pulled from database if this section has any children
		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides');

		var data = {
		    id: createGUID(),
		    programId: me.programId,
		    title: 'New Section',
		    content: null,
		    expanded: false,
		    children: [],
		    categoryId : App.ProgramPageCategoriesEnum.Chapter,
		    scoreMethod: 'A',
		    sequence: 1234

		};

		var parentNode = /*refs.treeSlides.getSelection()[0] ||*/ store.getRoot();
		slide = parentNode.appendChild(data);
		refs.treeSlides.setSelection(slide);
		me.saveState();
	},

	newSlide: function() {
		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides'),
		    parentNode = refs.treeSlides.getSelection()[0] || store.getRoot(),
		    slide,
			now = new Date();
		    data = {
		        id: createGUID(),
		        programId: me.programId,
		        sequence: me.getNumSlides(), // todo - this sequence might not be correct to write in database
		        title: 'New Page ' + (me.getNumSlides() + 1),
		        content: null,
		        expanded: true,
		        leaf: true,
		        isSlide : true,
		        categoryId : App.ProgramPageCategoriesEnum.Page,
		        scoreMethod: 'A',
				lastChanged: now,
				created: now

		    };

		if(parentNode.isLeaf()) {
		    parentNode = parentNode.parentNode;
		}

		slide = parentNode.appendChild(data);
		me.saveState();
		refs.treeSlides.setSelection(slide);

	},

	deleteSlide: function(slide) {
		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides'),
			deleteSlideWithContent= function(slide, treeStoreSlides, questionsStore) {
				// first decend down the tree to leaf
				if(slide.childNodes && slide.childNodes.length > 0){
					for(var i = 0; i < slide.childNodes.length; i++){
						deleteSlideWithContent(slide.childNodes[i], treeStoreSlides, questionsStore);
					}
				}
				// then delete my data and delete me
				// go through its components, check if its a question, then delete that question
				var components = (Ext.decode(slide.get('content') || '{}').components);
				if(components && Object.keys(components).length > 0){
					for (var key in components){
						var cmp = components[key];
						var cmpType = cmp.type;
						if (cmpType == me.cmpTypes.SELECTION || cmpType == "Single selection" || cmpType == "Multi selection") {
							// update store of that question component
							var rec = questionsStore.findRecord('id', cmp.id);
							questionsStore.remove(rec);

						}
					}
				}
				// remove this slide from tree store
				slide.parentNode.removeChild(slide);
			},



			deleteWrapup = function(slide){
				var treeStoreSlides = me.getStore('TreeStoreSlides'),
					questionsStore = me.getStore('QuestionsStoreSlides');
				// delete this slide with its subtree and conten of each slide in this tree
				deleteSlideWithContent(slide, treeStoreSlides, questionsStore);

				// set localstorage and sync with server if online
				me.saveState();
				me.clearSlidePanel();
				me.nextSlide();
			};

		slide = slide || me.getCurrentSlide();

		if(slide) {
		    var components = (Ext.decode(slide.get('content') || '{}').components),
		        childNodes = slide.childNodes; // child nodes are relevant if this section has any subpages

		    if((components && Object.keys(components).length > 0) || (childNodes && childNodes.length > 0)) {
		        Ext.Msg.confirm( 'Delete slide', 'Are you sure?' +
		                        ((childNodes && childNodes.length > 0)?
		                         " You will delete whole subtree!": ""), function(btn) {
		            if(btn == 'yes') {
						deleteWrapup(slide);
		            }
		        });
		    }
		    else {
				deleteWrapup(slide);
		    }
		}
	},

	getCurrentSlide: function() {
		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides');

		var currentSlideIdx = store.indexOf(me.currentSlide);


		me.currentSlide = refs.treeSlides.getSelection()[0] || store.getAt(currentSlideIdx);

		return me.currentSlide;
	},

	nextSlide: function() {
		// variable to recursively descend to first slide - if its set to false, we also visit sections
		var REC_TO_SLIDE = true;

		// if (REC_TO_SLIDE &&  this.getNumSlides() < 2){
		//     // there is 1 or 0 slides and recursion is set to true - which means we cannot visit sections so return
		//     return;
		// }

		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides'),
		    slide = me.getCurrentSlide(),
		    nextSlideIdx = store.indexOf(slide) + 1,
		    nextSlide = store.getAt(nextSlideIdx);

		if(nextSlide) {

		    refs.treeSlides.setSelection(nextSlide);
		    if (nextSlide.data.leaf === false){



		        me.nextSlide();

		        if(REC_TO_SLIDE){
		            // recursively iterate to leaf slide through section
		            if (this.getNumSlides() === 0){
		                //cannot switch recursively to next slide", "no slides exist
		                return;
		            }
		            if (me.getCurrentSlide().data.leaf === false){
		                me.prevSlide();
		            }
		        }



		    }
		}


	},

	prevSlide: function() {


		// variable to recursively ascend to first remaining slide - if its set to false, we also visit sections
		var REC_TO_SLIDE = true;

		// if (REC_TO_SLIDE &&  this.getNumSlides() < 2){
		//     // there is 1 or 0 slides and recursion is set to true - which means we cannot visit sections so return
		//     return;
		// }

		var me = this,
		    refs = me.getReferences(),
		    store = me.getStore('TreeStoreSlides'),
		    slide = me.getCurrentSlide(),
		    prevSlideIdx = store.indexOf(slide) - 1,
		    prevSlide = store.getAt(prevSlideIdx);


		if(prevSlide) {
		    refs.treeSlides.setSelection(prevSlide);
		    if (prevSlide.data.leaf === false){

		        me.prevSlide();

		        if(REC_TO_SLIDE){
		            // recursively iterate to leaf slide through section
		            if (this.getNumSlides() === 0){
		                //cannot switch recursively to prev slide", "no slides exist
		                return;
		            }


		            if (me.getCurrentSlide().data.leaf === false){
		                me.nextSlide();
		            }

		        }


		    }



		}
	},

	setBackground: function(src) {
		var me = this,
		    refs = me.getReferences();

		me._pageSetup.background = src;

		if(src) {
		    Ext.getCmp('panelContent').setStyle('background', 'url(' + src + ')');
		}
		else {
		    Ext.getCmp('panelContent').setStyle('background', null);
		}

		me.saveState();
	},

	togglePreview: function(preview, yesCallback) {
		// calls show preview or displays dialog option when closing preview - to directly close preview without dialog - call me.closePreview()

		var me = this,
		    refs = me.getReferences();

		if(preview){
		    me.showPreview();

		}else{
		    Ext.Msg.confirm( 'Close preview', 'Are you sure?' , function(btn) { // show confirm dialog
		        if(btn == 'yes') {
		            me.closePreview();
					if(yesCallback){ yesCallback(); }
		        } // else do nothing
		    });
		}
	},

	getFreePosition: function() {
		var me = this,
		    refs = me.getReferences(),
		    snap = me._pageSetup.snap,
		    pos = {
		        x: snap * 2,
		        y: snap * 2,
		        width: me.round(refs.panelContent.el.getWidth() - 2 * snap * 2),
		        height: snap * 2
		    };
		Ext.each(refs.panelContent.el.query('.html-component'), function(component) {
		    pos.y = me.round(Math.max(pos.y, component.y + component.height + snap));
		});

		return pos;
	},

	getSlideComponents: function() {
		/*var me = this,
			slide = me.getCurrentSlide(),
			record = me.getStore('TreeStoreSlides').findRecord('id', slide.id);
		if(record){
			print("get slide c omponents- found record");
			content = record.data.content;
			if(content){
				var components = Ext.decode(content).components;
				print("slide cmps, found components", components);
				return components;
			}
		}
		print("get slide cmps, record not found or no components");
		return "{}";

		*/
		return this.getReferences().panelContent.el.query('.html-component');
	},

	getCurrentState: function() {
		var me = this,
		    refs = me.getReferences(),
		    slides = Ext.clone(Ext.pluck(refs.treeSlides.store.getRange(), 'data')).map(function(node) {
		        return cleanTreeNodeData(node);
		    });
		     // make dict where key is its id

		    var slidesDict = {};
		    for (var i = 0; i < slides.length; i++){
		        slidesDict[slides[i].id] = slides[i];

		    }

		    questions = Ext.clone(Ext.pluck(me.getStore('QuestionsStoreSlides').getRange(), 'data')).map(function(node) {
		        //return cleanTreeNodeData(node);
		        return node;
		    });

		    // make dict where key is its id

		    var questionsDict = {};
		    for (var i = 0; i < questions.length; i++){
		        questionsDict[questions[i].id] = questions[i];

		    }



		    answers = Ext.clone(Ext.pluck(me.getStore('PersonAnswers').getRange(), 'data')).map(function(node) {
		        //return cleanTreeNodeData(node);
		        return node;
		    });

		    // make dict where key is its id

		    var answersDict = {};
		    for (var i = 0; i < answers.length; i++){
		        answersDict[answers[i].id] = answers[i];

		    }

		data = {
		        slides: slidesDict,
		        pageSetup: me._pageSetup,
		        questions: questionsDict,
				answers: answersDict
		    };

		return data;
	},

	loadSlideState: function(slide) {

		var me = this,
		    refs = me.getReferences(),
		    parentEl = refs.panelContent.el.down('#html-slide');

		me.clearSlidePanel();

		if(slide) {
		    var content = Ext.decode(slide.get('content') || '{}');
		    for (var key in content.components){
		        var component = content.components[key];
				if(!component.id){
					// if component itself doesnt have id, we append it - this is needed for questions when they are created offline
					component.id = key;
				}
		        this.insertComponent(component);
		    }
		}
	},

	clearSlidePanel: function() {
		var me = this,
		    refs = me.getReferences(),
		    parentEl = refs.panelContent.el.down('#html-slide');

		// remove components from panel
		Ext.each(parentEl.query('.html-component'), function(component) {
		    parentEl.removeChild(component);
		}, this);

		// deselect all components
		if(me._selectedComponents){
			for(var i = 0; i < me._selectedComponents.length; i++){
				me._selectedComponents[i].fireEvent('deselect');
			}
		}
		me._selectedComponents = [];
		me.allComponents = []; // clear old components from prev slide
		// hide tools
		me.hideComponentTools();
	},

	addComponentListeners: function(item) {
		var me = this,
		    item = Ext.get(item);

		item.on('deselect', function(e,t){
		    item.removeCls('selected');
		    /*if(item._resizer){
		              item._resizer.destroy();
		        item._resizer = null;

		        print("deleted resizer");
		    }*/
		});
		item.on('select', function(e,t){
		    me._selectedComponents.push(item);
		    item.addCls('selected');
		    /*if(!item._resizer){
		        me.createResizer(item);

		    }*/
		});
		item.on('click', function(e, t) {
		    if(e.stopPropagation){ e.stopPropagation(); }
		    if(me.previewing || (!e.ctrlKey && !e.shiftKey )){ // if we are previewing or we didnt hold multiselect buttons
		        for(var i = 0; i < me._selectedComponents.length; i++){
		            var cmp = me._selectedComponents[i];
		            cmp.fireEvent('deselect');
		        }
		        me._selectedComponents = []; // clear array
		        me.hideComponentTools();
		    }
		    else{
		        if (e.ctrlKey || e.shiftKey) {
		            // check if this component is already in array of selected components - in this case - remove it
		            var index = me._selectedComponents.indexOf(item);
		            if (index > -1) {
		                var removedItem = me._selectedComponents.splice(index, 1)[0];
		                item.fireEvent('deselect');
		                if(!me._selectedComponents.length){// disable tools if there are no more components selected

		                    me.hideComponentTools();
		                }
		                // no items selected anymore - return
		                return;
		            }
		        }
		    }
		    if(!me.previewing){
		        item.fireEvent('select');
		        me.showComponentTools(item);
		    }
		    if(me.previewing){
		        // previewing

		        // Handle checkboxes and radio buttons
		        var SELECTED_VALUE = t.getAttribute('idx'); // idx have checboxes and radio buttons
		        if (SELECTED_VALUE){
		            // getting array from html collection
		            var answers = Array.from(item.dom.children[0].children); // to change dom style
		            var answers_js =  item.el._opts.options; // to update javascript object and set answer to true/false


		            answers.shift(); // remove first text item (text) - all other are radio / check buttons

		            var type = answers[0].getAttribute('type');
		            switch(type) {
		                case 'radio':
		                    for (var i = 0, len = answers.length; i < len; i++) {
		                        answers[i].classList.remove('selected');
		                        answers_js[i].answer = false;
		                    }
		                    answers[SELECTED_VALUE].classList.add('selected');
		                    answers_js[SELECTED_VALUE].answer = true;
		                    break;
		                case 'check':
		                    // initialize all values to its previous value or "false" if it hasn't been checked yet
		                    for (var i = 0, len = answers_js.length; i < len; i++) {
		                        answers_js[i].answer = answers_js[i].answer || false;
		                    }
		                    // toggle the selected value
		                    answers[SELECTED_VALUE].classList.toggle("selected");
		                    answers_js[SELECTED_VALUE].answer = !answers_js[SELECTED_VALUE].answer;
		                    break;
		                default:
		                    console.warn("Caller - addComponentListeners", "Unsupported component type" ,type);
		            }
					var now = new Date();
					print("printing on answer switch person program", me.currentPersonProgram, me.currentPersonProgram.personTrainingProgramId);
					var recordAnswers = {
						questionId: item._opts.id,
						id: createGUID(),
						created: now,
						lastChanged: now,
						personProgramId: me.currentPersonProgram.personTrainingProgramId,
						answer:{},
						score: 0 // TEMP - TODO CHANGE RECORD AFTER EVALUATING
					};

		            // create record
		            for (var i = 0, len = answers_js.length; i < len; i++) {
		                recordAnswers.answer[i] = answers_js[i].answer;
		            }
		            recordAnswers.answer = Ext.encode(recordAnswers.answer);
		            var storageData = Ext.decode(localStorage.getItem('mxp_elearning'))[me.programId];
					storageData.answers[item._opts.id] = recordAnswers;
					if(item._opts.id === undefined){
						console.warn("undefineddddddddddd");
					}
					var answerRec = me.getStore('PersonAnswers').add(recordAnswers)[0];
					answerRec.phantom = true;

					// save this to localstorage - post answers only on quiz end, restore answers in localstorage and in store on page reload

					var data = me.getCurrentState();
					var localStorageData = Ext.decode(localStorage.getItem('mxp_elearning'));
					localStorageData[me.programId].answers = data.answers;
					localStorage.setItem('mxp_elearning', Ext.encode(localStorageData));
		        }
		    }
		});
		item.on('dblclick', function(e, t) {
		    if(!me.previewing){
		        me.editComponent(item);
		    }
		});

		item.on('_edit', function(e, t) {
		    if(!me.previewing){
		        me.editComponent(item);
		    }
		});

		item.on('_duplicate', function(e, t) {
		    if(!me.previewing){
		        me.duplicateComponent(item);
		    }
		});

		item.on('_delete', function(e, t) {
		    if(!me.previewing){
		        me.deleteComponent(item, true); // sync is true
		        me.hideComponentTools(item);

		    }
		});

	},

	showComponentTools: function(component) {
		var me = this;

		if(!me._componentTools) {
		    me._componentTools = me.getView().add({ xtype: 'edittools' });
		}
		me._componentTools.getController().show({ components: me._selectedComponents });
	},

	hideComponentTools: function(component) {
		var me = this;

		if(!me._componentTools) {
		    me._componentTools = me.getView().add({ xtype: 'edittools' });
		}
		me._componentTools.close();

	},

	insertComponent: function(opts, callback) {
		opts = Ext.applyIf(opts || {}, {
		    type: null,
		    height: null,
		    width: null,
		    x: null,
		    y: null,
		    html: '',
		    options: [],
		    multi: false,
		    src: '',
		    cls: null,
		    style: null
		});

		if (!opts.type) {
		    console.warn('Error', 'No component type');
		    return;
		}


		if (opts.cls && typeof opts.cls == "string") {
		    opts.cls = [opts.cls];
		}

		var me = this,
		    refs = me.getReferences(),
		    pos = me.getFreePosition(),
		    snap = me._pageSetup.snap,
		    parentEl = refs.panelContent.el.down('#html-slide'),
		    cmp = document.createElement('div'),
		    currentSlide = me.getCurrentSlide();

		if(!me.currentSlide){
			me.newSlide();
		}

		// set size
		// if(opts.type == 'image' && opts.src) {
		//     // determine image size
		//     var img = new Image();

		//     img.onload = function() {
		//         cmp.width = me.round(isNull(opts.width, img.width));
		//         cmp.height = me.round(isNull(opts.height, img.height));
		//         cmp.style.width = cmp.width + 'px';
		//         cmp.style.height = cmp.height + 'px';
		//     };
		//     img.src = opts.src;

		//     // show image as background
		//      cmp.style.backgroundImage = 'url(' + opts.src + ')';
		// }
		// else {

		opts.x = cmp.x = pos.x = me.round(opts.x || pos.x);
		opts.y = cmp.y = pos.y = me.round(opts.y || pos.y);
		opts.width = cmp.width = pos.width = me.round(opts.width || pos.width);
		opts.height = cmp.height = pos.height = me.round(opts.height || pos.height);

		cmp.style.width = cmp.width + 'px';
		cmp.style.height = cmp.height + 'px';
		// }

		// set classes
		cmp.classList.add('html-component');

		// set position
		cmp.x = opts.x = isNull(opts.x, pos.x);
		cmp.y = opts.y = isNull(opts.y, pos.y);
		cmp.style.left = cmp.x + 'px';
		cmp.style.top = cmp.y + 'px';

		// set content
		var content = document.createElement('div');
		var html = opts.html;

		// todo - simplify this if - but from server opts.type is returned as Single or Multi selection because it doesnt have special attribute
		if ((opts.type == me.cmpTypes.SELECTION && opts.options) || opts.type == 'Single selection' ||opts.type == "Multi selection") {
		    cmp.style.height = ''; // remove height property from component so it will default to 100%
		    opts.cls = [me.cmpTypes.SELECTION];


		    // insert selection has been called with specific id, so we must retrieve it from database end spawn it here
		    /*var storageData = Ext.decode(localStorage.getItem('mxp_elearning'))[me.programId],
		        questions = storageData.questions,
		        question = questions[opts.id];
			*/
			 var question = me.getStore('QuestionsStoreSlides').findRecord('id',opts.id);
		    if(!question){
		        console.warn("No questions exist for this program. Returning...");
		        return;
		    }


		    var record = question.data;
		    opts.type = record.fieldType;
		    // TODO - FIx this line below because its inefficient -
		    opts.options = Ext.decode(record.lookups) || Ext.decode(record.answers.answer) || Ext.decode(record.answers);
		    html = record.question;
		    // todo we dont store in database if question is multi answer or not so in editSelection this text is rendered
		    opts.multi = opts.type == "Multi selection"; // checks against string if its multi selection
		    opts.html = html;
		    opts.cls = [me.cmpTypes.SELECTION];
		    opts.id = opts.id;

		    html = '<div clas="text">' + html + '</div>';

		    Ext.each(opts.options, function (option, index, allItems) {
		        var cls = ['option', (opts.multi ? 'check' : 'radio')];

		        if (option.correct) {
		            cls.push('correct');
				}

				// find answers in answers store - newly created components dont have answers yet so 'selected' wont be applied
				var answerRecord = me.getStore('PersonAnswers').findRecord('questionId', opts.id); // find record by questionGuid
				if(answerRecord){
					if(Ext.decode(answerRecord.data.answer)[index] === true){
						cls.push('selected');
					}
				}

		        // added two custom attributes idx which is index of element (starting with 0) and type which can contain chech or radio
		        html += '<div class="' + cls.join(' ') + '" idx=' + index + ' type=' + (opts.multi ? 'check' : 'radio') + '>' + option.text + '</div>';
		    });
		}

		if (opts.type == me.cmpTypes.IMAGE && opts.src) {
		    if(navigator.onLine){
		        content.style.backgroundImage = 'url(' + opts.src + ')';
		    }else{
		        content.style.backgroundColor = 'powderblue';
		        html = 'Image cannot be loaded - go online to view photo';
		    }
		}

		// adding classes to surrounding div element of component
		content.classList.add('html-content');
		Ext.each(opts.cls, function (cls) {
		    content.classList.add(cls);
		});

		content.innerHTML = html;
		content = cmp.appendChild(content);
		cmp = parentEl.dom.appendChild(cmp);

		cmp.style.height = me.round(cmp.clientHeight)+'px'; // again make sure that components are snapping to corrent grid

		// check if content is overflowing the panel - reset it back to bottom of panel
		if(pos.y +  me.round(cmp.clientHeight) > refs.panelContent.el.getHeight()){
		    opts.y = cmp.y = pos.y =  me.round(refs.panelContent.el.getHeight() -  cmp.clientHeight);
		    cmp.style.top = opts.y+'px';
		}

		cmp._opts = opts;
		cmp.type = opts.type;

		extCmp = Ext.get(cmp);
		extCmp._opts = opts;
		extCmp.type = opts.type;


		if (!me.previewing) {
		    cmp._dragger = new Ext.drag.Source({
		        element: extCmp,
		        constrain: {
		            element: parentEl,
		            snap: {
		                x: snap,
		                y: snap
		            }
		        },
		        listeners: {
		            beforedragstart: function (component, info, event, eOpts) {
		                component.config.element.fireEvent('click');
		                if (info.eventTarget.classList.contains('x-resizable-handle')) {
		                    return false;
		                }
		            },
		            dragcancel: function (component, info, event, eOpts) {
		                var prevWrapper = document.getElementById("lineWrapper");
		                if(prevWrapper){
		                    prevWrapper.outerHTML = ""; // remove old wrapper
		                }
		            },
		            dragend: function (component, info, event, eOpts) {
		                var prevWrapper = document.getElementById("lineWrapper");
		                if(prevWrapper){
		                    prevWrapper.outerHTML = ""; // remove old wrapper
		                }

		                var id = component.config.element._opts.id;
		                var currentSlide = me.getCurrentSlide();

		                // THIS FUNCTION NOW WORKS FOR ALL - IMAGES, AUDIO, SELECTIONS, BECAUSE EVERYONE HAS ITS OWN ID

		                // set new info to this new altered component
		                var alteredContent = Ext.decode(currentSlide.data.content);
		                for (var key in alteredContent.components){
		                    if(alteredContent.components[key].id == id){
		                        alteredContent.components[key].x = component._element.dom.offsetLeft;
		                        alteredContent.components[key].y = component._element.dom.offsetTop;
		                    }
		                }
		                // change store and sync
		                var storeItems = me.getStore('TreeStoreSlides').data.items;
		                for(var i = 0; i < storeItems.length; i++){
		                    if(storeItems[i].id == currentSlide.id){

		                        storeItems[i].data.content = Ext.encode(alteredContent);
		                        storeItems[i].data.lastChanged = new Date();
		                        storeItems[i].phantom = true;
		                        break;
		                    }
		                }
						me.saveState();
		            },
		            dragmove: function (component, info, event, eOpts) {
		                // Todo - drag move multiple componets at once - when holding down to drag, only 1 component is selected
		                for(var i = 0; i < me._selectedComponents.length; i++){
		                    var selectedCmp = me._selectedComponents[i];
		                    selectedCmp._opts.x = selectedCmp.dom.offsetLeft;
		                    selectedCmp._opts.y = selectedCmp.dom.offsetTop;
		                }
		                me.drawHelperLines(component); // todo draw helper lines for whole bounding box of all selected components

		                me.showComponentTools(component);
		            },
		            dragstart: function (component, info, event, eOpts) {

		                component.config.element._opts.x = component._element.dom.offsetLeft;
		                component.config.element._opts.y = component._element.dom.offsetTop;


		                me.drawHelperLines(component);

		            }
		        }
		    });

		    me.createResizer(cmp);

		}

		me.addComponentListeners(cmp);
		me.allComponents.push(extCmp); // append this newly created component to all components, so we can select it later

		if(callback){ callback(); }

		return extCmp;
	},

	editComponent: function(component) {
		var me = this,
		    refs = me.getReferences();

		component = component || me._selectedComponent;
		if (component) {
		    if ((component.type == me.cmpTypes.IMAGE) || (component.type == me.cmpTypes.VIDEO) || (component.type == me.cmpTypes.AUDIO) ){
		        console.warn("Cannot edit image, video or audio");
		        return;
		    }

		    if (component.type == me.cmpTypes.SELECTION || component.type == "Single selection" || component.type == "Multi selection") {
		        me.editSelection(component);
		    }

		    else {
		        var wnd = me.getView().add({xtype: 'texteditor'});

		        wnd.getController().show({
		            value: component.el.down('.html-content').dom.innerHTML,
		            callback: function (value) {
		                component.el.down('.html-content').dom.innerHTML = value;
		                component._opts.html = value;
		                me.saveState();
		            },
		            scope: me
		        });
		    }
		}
	},

	duplicateComponent: function(component) {
		var me = this,
		    component = Ext.clone(component);
		var opts = Ext.clone(component._opts);

		delete opts.x;
		delete opts.y;

		var cmpType = component._opts.type;
		if (cmpType == me.cmpTypes.SELECTION || cmpType == "Single selection" || cmpType == "Multi selection") {
		    opts.text = component._opts.html;
		    opts.answers = component._opts.options;
		    me.createSelection(opts);
		}

		else{
		    // for all other components - call ordinary insert component

		    // rename its id
		    opts.id = createGUID();
		    var cmp = this.insertComponent(opts);

		}
		me.saveState();
	},

	deleteComponent: function(component, sync) {
		var me = this,
			refs = this.getReferences(),
			questionStore = me.getStore('QuestionsStoreSlides'),
			treeStoreSlides = me.getStore('TreeStoreSlides');

		if(component) {

			if(sync){ // we might not always want to sync, but only delete this component in order to redraw it
				var rec = questionStore.findRecord('id', component.el._opts.id);
				questionStore.remove(rec);

				// deleting by find
				questionStore.removeAt(questionStore.find('id',  component.el._opts.id));
				for (var i = 0; i < questionStore.data.items.length; i++){
					var rec = questionStore.data.items[i];
					rec.phantom = false;
					if(rec.id == component.el._opts.id){
						rec.data.lastChanged = new Date();
						rec.phantom = true;
					}
				}
				// remove component from slide content and set its record.phantom to true, for it to later update
				var id = component.el._opts.id;
				var currentSlide = me.getCurrentSlide();


				// set new info to this new altered component
				var removedComponentsArray = {};
				var slideContent = Ext.decode(currentSlide.data.content);
				for (var key in slideContent.components){
					if(slideContent.components[key].id != id){
						// add every other component than the one we are deleting
						removedComponentsArray[key] = slideContent.components[key];
					}
				}
				var componentsDict = {'components': removedComponentsArray};

				// change store and sync
				var store = me.getStore('TreeStoreSlides');
				var rec = store.findRecord('id', currentSlide.id);
				// update record
				rec.data.content = Ext.encode(componentsDict);
				rec.data.changed = 'Y';
				rec.data.lastChanged = new Date();
				rec.phantom = true;



			}
			if(!me.allComponents){
				console.warn("Error - For some reason this component was not in >allComponents< array.");
				me.allComponents.remove(component);
			}

			component.destroy();
			component = null;

			if(sync){
				// save state
				me.saveState(); //save changes to localstorage and sync with server if online
			}
		}
	},

	insertTitle: function(value) {
		var me = this,
		    cmp = me.insertComponent({

		        id: createGUID(),
		        type: me.cmpTypes.TITLE,
		        cls: 'title',
		        html: value || 'Title',
		        height: 50

		    });



		 me.saveState();

	},

	insertText: function(value) {
		var me = this,
		    cmp = me.insertComponent({
		        id: createGUID(),
		        type: me.cmpTypes.TEXT,
		        cls: 'text',
		        html: value || 'Text',
		        height: 425

		    });
		 me.saveState();

	},

	insertImage: function() {
		var me = this,
		    cmp = me.insertComponent({
		        id: createGUID(),
		        type: me.cmpTypes.IMAGE,
		        cls: 'image',
		        html: '',
		        src: 'resources/images/example.jpg',
		        height: 275,
		    });
		 me.saveState();
	},

	insertSelection: function(opts) {
		this.editSelection(null, opts);

	},

	editSelection: function(component, opts) {
		opts = Ext.applyIf(opts || {}, {
		    multi: false
		});

		var me = this,
		    refs = me.getReferences(),
		    state = component && component._opts,
		    multi = state && state.multi || opts.multi,
		    wnd = me.getView().add({ xtype: 'selectioneditor' });

		wnd.getController().show({
		    text: state && state.html,
		    options: state && state.options,
		    multi: multi,
		    callback: function(text, answers) {
		        var opts = {
		            text: text,
		            answers: answers,
		            multi:multi,
		            component : component
		        };

		        me.createSelection(opts);

		    },
		    scope: me
		});
	},

	round: function(value) {
		var snap = this._pageSetup.snap;

		return Math.round(value / snap) * snap;
	},

	ceil: function() {
		var snap = this._pageSetup.snap;

		return Math.ceil(value / snap) * snap;
	},

	insertAudio: function() {
		var me = this,
		    cmp = me.insertComponent({
		        id: createGUID(),
		        type: me.cmpTypes.AUDIO,
		        cls: 'audio',
		        html: '<audio controls>  <source src="resources/audio/horse.mp3" type="audio/mpeg">Your browser does not support the audio element.</audio>',
		        src: 'resources/audio/horse.mp3',
		        height: 50,
		    });
		me.saveState();
	},

	insertVideo: function() {
		var me = this,
		    cmp = me.insertComponent({
		        id: createGUID(),
		        type: me.cmpTypes.VIDEO,
		        cls: 'video',
		        html: '<video width="320" height="240" controls>  <source src="resources/videos/mov.mp4" type="video/mp4"> Your browser does not support the video tag.</video>',
		        src: 'resources/videos/mov.mp4',
		        height: 240,
		    });
		me.saveState();
	},

	getNumSlides: function() {
		// Retrieves count of slides (sections don't count)
		var me = this,
		    countSlides = 0,
		    data = Ext.decode(localStorage.getItem('mxp_elearning'))[me.programId];
		if(!data.slides || !Object.keys(data.slides).length){
		    return 0;
		}
		for(var key in data.slides){
		    if(data.slides[key].isSlide ||data.slides[key].categoryId == App.ProgramPageCategoriesEnum.Page){
		        countSlides += 1;
		    }
		}
		return countSlides;
	},

	evaluate: function() {
		// returns [singleSelectionCorrect, singleSelectionQuestions, multipleSelectionScore, multipleSelectionScoreUsingNegative]
		// multipleSelectionScore -> if answer_correct -> answer_score += 1/num_answers
		//							 else: answer_score = (answer_score - 1/num_answers).clamp(0, num_answers)
		//multipleSelectionScoreUsingNegative -> dont clamp incorrectly answered
		Number.prototype.clamp = function (min, max) {
		    return Math.min(Math.max(this, min), max);
		};

		// iterate through slides and questions and check score:
		var me = this,
		    usingNegativeScore = false, // config variable which determines if each answer can have negative return points
		    programScore = {"questions":{}, "totalProgramScore": -1};

		var questions = me.getStore('QuestionsStoreSlides').data.items;
		var answersStore = me.getStore('PersonAnswers');
		for(var i = 0; i < questions.length; i++){

		    var question = questions[i].data;
		    var answer = answersStore.findRecord('questionId', question.id).data.answer;
		    programScore.questions[question.id] = me.getScore(question, answer, usingNegativeScore);
		}

		// suming questions scores to total score
		var totalProgramScore = sumDict(programScore.questions);
		//console.log('%c printing final user score:', totalProgramScore, 'color: green');
		//console.log("printing final user score:", totalProgramScore);
		if(totalProgramScore >= me.programData.passScore){
			console.log("%cFinal user score:", "color: green", totalProgramScore, "Percentage correct - ", ((totalProgramScore /  me.programData.passScore)* 100) + "%" );
		}
		else{
			console.log("%cFinal user score:", "color: red", totalProgramScore,"Percentage correct - ",  ((totalProgramScore /  me.programData.passScore)* 100) + "%" );
		}




		programScore.totalProgramScore = totalProgramScore;

		return programScore;
	},

	getScore: function(question, answer, usingNegativeScore) {
		if(!answer){
		    // user didnt check any options on this question - return
		    return 0;
		}
		answer = Ext.decode(answer);

		var answerScore = 0;
		var correctAnswer;
		var usersAnswer = answer;

		// TODO - why does question have multiple attributes that represent same thing - store them under same name!!
		var _question = Ext.decode(question.options || question.lookups ||question.answers); // in datase options are stored in lookups table so we return lookups
		var questionNumAnswers = _question.length;

		if (question.multi || question.fieldType == "Multi selection") { // Todo - decide which attribute to use!!
		    // make a pre-pass counting num_correct_answers
		    var numCorrectAnswers = 0;
		    _question.forEach(function (option) {

		        if (option.correct) {
		            numCorrectAnswers += 1;
		        }
		    });
		    // go through all questions in this form

		    for(var i = 0; i < _question.length; i++){
		        usersAnswer = answer[i];
		        correctAnswer = _question[i].correct;
		        if (usersAnswer == correctAnswer) {
		            if (correctAnswer === true) {
		                // if we checked correct answer - add percent of all correct answers to his score
		                answerScore += (1 / numCorrectAnswers);
		            }
		            // no else - we are not rewarding for not checking not-correct answers
		        }
		        else{
		            // we didnt click what is correct

		            if (correctAnswer === true) {
		                // if we clicked no but answer was yes, punish user by subtracting percent of all correct answers from his score
		                answerScore -= (1 / numCorrectAnswers);
		            }
		            else{
		                // if we clicked yes but answer was no, punish user by subtracting only percent of num answers
		                answerScore -= (1/ questionNumAnswers);
		            }
		        }
		    }

		    // append score of this questionary to totalScore
		    if(!usingNegativeScore){
		        // clamp between 0 and max
		        answerScore = (answerScore).clamp(0, questionNumAnswers);
		    }

		} else {
		    // evaluate
		    for(var i = 0; i < _question.length; i++){
		        usersAnswer = answer[i];
		        correctAnswer = _question[i].correct;


		        if ((correctAnswer === true) && (usersAnswer == correctAnswer)) {
		            answerScore = 1;
		        }
		        else {
		            if(usersAnswer == correctAnswer){
		                // this is not right answer but we checked right one

		                if(usingNegativeScore){
		                    // returns -1 - is this too much?
		                    answerScore = -1;
		                }
		                // else return 0
		            }
		        }

		    }

		}

		return answerScore;
	},

	saveState: function() {
		var me = this,
		    refs = me.getReferences(),
		    content = {
		        components: {}
		    };

		// first update current slide
		slide = me.getCurrentSlide();
		if(slide) {
			var slideComponents = me.getSlideComponents();
			for (var key in slideComponents){
				var component = slideComponents[key];
				if(component._opts.type == me.cmpTypes.SELECTION){
		            // if its question, append only guid of this question to content components
		            var _opts = Ext.clone(component._opts);

		            var _optsNew = {"type": _opts.type, "id": _opts.id };
		            content.components[_opts.id]=_optsNew;
		        }else{
		            // append whole content
		             content.components[component._opts.id] = component._opts;
		        }
			}

		    //slide.set('lastChanged', new Date()); // set last changed for this slide here
		    slide.set('content', Ext.encode(content));
		}



		var data = this.getCurrentState();

		var localStorageData = Ext.decode(localStorage.getItem('mxp_elearning'));
		for (var key in data) {
		    localStorageData[me.programId][key] = data[key];
		}

		if(navigator.onLine){
			// sync all stores
			me.getStore('TreeStoreSlides').sync();
			me.getStore('QuestionsStoreSlides').sync();
			me.getStore('PersonPrograms').sync();
		}


		// sets current state to localstorage and calls update with server
		localStorage.setItem('mxp_elearning', Ext.encode(localStorageData));
	},

	setInitialSlide: function() {
		// this function is used to set slide after syncing with server or initially recieving data (from localstorage or server)
		var me = this,
		    refs = me.getReferences();

		var currentSlide = me.getCurrentSlide();
		if(currentSlide){
			refs.treeSlides.setSelection(null);
		    refs.treeSlides.setSelection(currentSlide);
		    return;
		}
		// this part of code gets executed when there is no current selection yet


		// switch to first slide
		Ext.defer(function() {
		    me.nextSlide();
		}, 100);

		me.setBackground(me._pageSetup.background);
		refs.panelContent.setWidth(me._pageSetup.width);
		refs.panelContent.setHeight(me._pageSetup.height);
	},

	initialDataSync: function(storeName, localStorageAttribute, LoadParams, callback, dataId) {
		if (!navigator.onLine){
			//You are offline - cannot sync with server
			if(callback){
				callback();
			}
			return;
		}

		var me = this,
			localStorageData = Ext.decode(localStorage.getItem('mxp_elearning')),

			initialDataStore = me.getStore(storeName);

		initialDataStore.load({
			params: LoadParams,

			callback: function(records, operation, success){
				if(initialDataStore.data.length === 0){
					// no return data, check if there are any locally saved localStorageAttribute

					if(localStorageData && localStorageData[me.programId] && localStorageData[me.programId][localStorageAttribute]){
						//we have locally saved localStorageAttribute, syncing with server
						// data for this programId exists - reassign it
						localStorageData = localStorageData[me.programId];
						for (var key in localStorageData[localStorageAttribute]){
							var localStorageEntry = localStorageData[localStorageAttribute][key];

							if(localStorageAttribute == 'slides'){
								// we must append this slide not add
								initialDataStore.getRootNode().appendChild(localStorageEntry);
								initialDataStore.findRecord('id', localStorageEntry.id).phantom = true;
							}
							else{
								var rec = initialDataStore.add(localStorageEntry)[0];
								rec.phantom = true;
							}
						}
					}
					if(callback){ callback();}
					return;
				}

				// here we have valid return data from server, so we can update localstorage and sync localstorage back with server
				if(!localStorageData || !localStorageData[me.programId]){
					// no data yet in localstorage
					localStorageData = me.getCurrentState();
					initialDataStore.data.items.forEach(function(entry){
						localStorageData[localStorageAttribute].push(entry.data);
					});
					if(callback){ callback(); }
					return;
				}

				// data for this programId exists - reassign it
				localStorageData = localStorageData[me.programId];

				if(!localStorageData[localStorageAttribute]){
					//no entries yet in localstorage
					// localstorage slides are empty - set recieved data from server to localstorage - even if it is empty

					var entriessFromStore = {};
					for (var i = 0; i < initialDataStore.data.length; i++){
						var entry = initialDataStore.data.items[i].data;
						entriessFromStore[entry[dataId]] = entry;
					}

					// add localStorageAttribute from store to localstorage[programId] under localStorageAttribute key
					localStorageData[localStorageAttribute] = entriessFromStore;

					if(callback){ callback(); }
					return;
				}

				function containsObject(obj, list) {
					for (var i = 0; i < list.length; i++) {
						if (list[i].id == obj.id) {
							return i;
						}
					}
					return -1;
				}

				// we dont have to worry about deleted components/slides

				for (var key in localStorageData[localStorageAttribute]){
					var localStorageEntry = localStorageData[localStorageAttribute][key];
					var objectIndex = containsObject(localStorageEntry, initialDataStore.data.items); // get index of this item
					if(objectIndex > -1) { // if returned index 0,1,2..
						// we found localstorage entry in store - update it

						if(localStorageEntry.lastChanged > initialDataStore.data.items[objectIndex].data.lastChanged){
							// update entry in
							var rec = initialDataStore.findRecord('id', localStorageEntry.id);
							rec.data = localStorageEntry;
							rec.phantom = true;
						}
					}else{
						if(localStorageAttribute == 'slides'){
							// for tree store, we add data to it by appending it to root node
							initialDataStore.getRootNode().appendChild(localStorageEntry);
							initialDataStore.findRecord('id', localStorageEntry.id).phantom = true;
						}
						else{
							// for all other stores - that are json stores we can add entry normally
							var rec = initialDataStore.add(localStorageEntry)[0];
							rec.phantom = true;
						}
					}
				}
				// dont save state here - it will overwrite all localstorage data that hasnt been synced yet with server

				if(callback){ callback(); }
			}
		});


	},

	closePreview: function() {
		print("called close preview");

		var TEST_PERSON_ID = 10000112;


		var me = this,
		    refs = me.getReferences(),
		    personProgramsStore = me.getStore('PersonPrograms'),
		    personAnswersStore = me.getStore('PersonAnswers');

		me.previewing = false; // setting current previewing state

		// we / timer toggled preview off - validate forms and submit

		// get scores for each question and total
		var programScore = me.evaluate();
		var questionsScores = programScore.questions;
		var totalProgramScore = programScore.totalProgramScore;


		// submit answers to server
		personAnswersStore.sync();


		// GOOD TO KNOW - batchActions is disabled on store, so every request is handled on its own ->batchActions: false,

		if(!me.currentPersonProgram){
		    console.warn("for some reason current person program id is not set - it should be created new if person doesnt have any records yet or it should be recieved from store.");
		    return;
		}


		// get score results:
		var scoreResults;


		if(me.currentPersonProgram.attempt < me.programData.maxAttemptsTrainingMode + me.programData.maxAttemptsScoreMode){
		    if(totalProgramScore >= me.programData.passScore){
		        // we passed
		        scoreResults = App.ProgramStatuses.Passed;
		    }else{
		        // we tried non -last time and we failed - status is chagned to discontinued
		        scoreResults = App.ProgramStatuses.Discontinued;
		    }
		}else{
		    if(totalProgramScore < me.programData.passScore){
		        // if we tried last time and we didn't get enough we failed
		        scoreResults = App.ProgramStatuses.Failed;
		    }else{
		        // we tried last time and we passed
		        scoreResults = App.ProgramStatuses.Passed;
		    }
		}

		var rec = personProgramsStore.add({ // TODO - this is add function but old record is still in there
		    personProgramGuid: me.currentPersonProgram.personTrainingProgramId,
		    lastChanged: new Date(),
		    programCompleted: new Date(),
		    programStatusId: scoreResults,
		    changed: 'Y'
		})[0];

		// setting phantom to true in order to update
		rec.phantom = true;

		personProgramsStore.sync();

		clearInterval(me.previewTimer);

		me.togglePreviewFrame(false);

		// reset button to default
		var previewButton = Ext.getCmp('btnPreview');
		previewButton.removeCls('active-program');
		previewButton.setText('Preview');
	},

	showPreview: function() {
		var TEST_PERSON_ID = 10000112;


		var me = this,
		    refs = me.getReferences(),
		    personProgramsStore = me.getStore('PersonPrograms'),
		    personAnswersStore = me.getStore('PersonAnswers');

		me.previewing = true; // setting current previewing state


		var numQuestions = Object.keys(Ext.decode(localStorage.getItem('mxp_elearning'))[me.programId].questions).length;

		if(this.getNumSlides() === 0){
		    Ext.toast("Unable to preview program with no pages.");
		    return;
		}
		if(numQuestions === 0){
		    Ext.toast("Unable to start preview with no questions.");
		    return;
		}









		if(me.programData.validTo < new Date()){
		    Ext.toast("Program is not valid anymore!");
		    Ext.get('btnPreview').disable();
		    return;
		}

		// Create PersonProgram or update it here


		personProgramsStore.load({
		    params:{
		        personId: TEST_PERSON_ID,
		        programId: me.programId
		    },
		    callback:function(record){
		        if(!record || record.length === 0){
		            //recieved no record back - maybe here we know that this persons program doesnt exist yet so add it

					 Ext.Msg.confirm( 'Start preview', 'Start your first preview?' , function(btn) { // show confirm dialog
						 if(btn == 'yes') {
							 me.currentPersonProgram = { // store whole record
								 personProgramGuid: createGUID(),
								 personId: TEST_PERSON_ID,
								 programId: me.programId,
								 programStatusId: App.ProgramStatuses["In Progress"],
								 createdById: TEST_PERSON_ID, // TODO - same person is also creating this program? can this be different?
								 created: new Date(),
								 programStarted: new Date(),
								 lastChanged: new Date(),
								 changed: 'N',
								 attempt: 0,
							 };
							 var rec = personProgramsStore.add(me.currentPersonProgram)[0];
							 rec.phantom = true;
							 personProgramsStore.sync();
							 me.switchToPreviewing(); // display new quiz
						 }
					 });
		        }


		        else{
		            me.currentPersonProgram = record[0].data;
		            if(me.currentPersonProgram.attempt >= me.programData.maxAttemptsTrainingMode + me.programData.maxAttemptsScoreMode){
		                //Cannot attempt any more tries... returning
		                return;
		            }


		            // here we can read the records id to use in posting answers
		            // add completion time minutes to initial programStarted time
		            var endTime = new Date(new Date(me.currentPersonProgram.programStarted).getTime() +
		                                   me.programData.completionTime * 60000); // completion time in database is in minutes
		            var remainingMS = endTime.getTime() - new Date().getTime();

		            if(remainingMS > 0 && (me.currentPersonProgram.programStatusId == App.ProgramStatuses["In Progress"] ||
		                                   me.currentPersonProgram.programStatusId == App.ProgramStatuses.Repeat)){

		                me.switchToPreviewing();  // display still active try of this quiz
		            }else{

		                //we show dialog that by proceeding we will use another try
		                Ext.Msg.confirm( 'Start preview', 'Start new program preview?' , function(btn) { // show confirm dialog
		                    if(btn == 'yes') {


		                        // create new current person program
		                        me.currentPersonProgram = {
		                            personProgramGuid: me.currentPersonProgram.personTrainingProgramId,
		                            attempt: me.currentPersonProgram.attempt +1, // increase attempt counter
		                            lastChanged: new Date(),
		                            changed : 'Y',
		                            programStatusId: App.ProgramStatuses.Repeat, // TODO - does status repeat mean "in progress && tried non -first time"
		                            programStarted: new Date(),

		                        };

		                        var rec = personProgramsStore.add(me.currentPersonProgram)[0];
		                        rec.phantom = true;
		                        personProgramsStore.sync();
		                        me.switchToPreviewing(); // display new try of this quiz
		                    }
		                });
		            }

		            // else - we have still time from previous quiz so continue with that one
		            // POSSIBLE PROBLEM - if user wants to manually restart quiz - close one and start another - it will reopen old one
		        }
		    }
		});
	},

	togglePreviewFrame: function(preview) {
		// Display content
		var me = this,
		    refs = me.getReferences();
		//refs.panelMenu.setVisible(!preview); // commented so navigation tree is visible even when solving quiz
		refs.toolbarEdit.setVisible(!preview);
		refs.toolbarPreview.setVisible(!!preview);
		refs.panelContent[preview ? 'removeCls' : 'addCls']('edit');
		refs.panelContent[preview ? 'addCls' : 'removeCls']('preview');

		refs.panelSlide.setMargin(preview ? '10' : '10 10 10 0');

		// retarget this slide - this redraws current slide without dragger and sizer
		var currentSlide = me.getCurrentSlide();
		refs.treeSlides.setSelection(null);
		refs.treeSlides.setSelection(currentSlide);
	},

	switchToPreviewing: function() {
		var me = this,
		    refs = me.getReferences();

		// Update the count down every 1 second
		me.previewTimer = setInterval(function() {
		    // add completion time minutes to initial programStarted time
		    var endTime = new Date(new Date(me.currentPersonProgram.programStarted).getTime() +
		                           me.programData.completionTime * 60000); // completion time in database is in minutes
		    var now = new Date();


		    // Find the distance between now an the count down date
		    var distance = endTime.getTime() - now.getTime();

		    // Time calculations for days, hours, minutes and seconds
		    var days = Math.floor(distance / (1000 * 60 * 60 * 24));
		    var hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
		    var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
		    var seconds = Math.floor((distance % (1000 * 60)) / 1000);


		    var timerCountdownText = refs.toolbarPreview.el.down('#timerCountdown');
		    timerCountdownText.dom.innerHTML = "Remaining: " + days + "d " + hours + "h " + minutes + "m " + seconds + "s ";

		    // If the count down is finished, write some text
		    if (distance < 0) {
		        clearInterval(me.previewTimer);

		        timerCountdownText.dom.innerHTML = "EXPIRED";
		        Ext.toast("Time is up! We will evaluate your score.");


		        me.closePreview();
		        // Ext.getCmp('btnPreview').disable(); // - todo maybe disable button after we finished all tries

		    }
		}, 1000);







		// show slide state

		var firstSlide = refs.treeSlides.store.getAt(0);
		refs.treeSlides.setSelection(firstSlide);
		// on panel toggle - drop down the sections to first actual slide
		if (firstSlide.data.leaf === false){
		    me.nextSlide();
		}

		me.togglePreviewFrame(true);

	},

	drawHelperLines: function(component) {
		var me = this,
		    _component = component.config.element? component.config.element: component.el,
		    refs = me.getReferences(),
		    panelWidth = refs.panelContent.el.getWidth(),
		    panelHeight = refs.panelContent.el.getHeight(),
		    componentWidth =_component._opts.width,
		    componentMiddleWidth = componentWidth / 2,
		    componentHeight =_component._opts.height,
		    componentMiddleHeight = componentHeight / 2,
		    x = _component._opts.x,
		    y = _component._opts.y;

		var svgContent = `<svg height="` + panelHeight+`" width="` + panelWidth + `">`;
		// get all components and compare if some line is intersecting its bounding box or middle
		var currentSlide = me.getCurrentSlide();
		var slideComponents = Ext.decode(currentSlide.data.content);
		for (var key in slideComponents.components){
		    if(key != _component._opts.id){

		        var neighbourCmp = slideComponents.components[key];

		        //Todo - multiple lines will draw over the same spot if multiple components have for example same x
		        if(neighbourCmp.x == x){
		            svgContent+= `<line x1=" ` +x +`" y1="0" x2="` +x +`" y2="`+panelHeight+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>`;
		        }
		        if(neighbourCmp.x + neighbourCmp.width /2 == x + componentMiddleWidth){
		            svgContent+= `<line x1=" ` +(x + componentMiddleWidth) +`" y1="0" x2="` +(x + componentMiddleWidth) +`" y2="`+panelHeight+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>`;

		        }
		        if(neighbourCmp.x + neighbourCmp.width == x + componentWidth){
		            svgContent += `<line x1=" ` +(x + componentWidth) +`" y1="0" x2="` +(x + componentWidth) +`" y2="`+panelHeight+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>`;
		        }


		        if(neighbourCmp.y == y){
		            svgContent += `<line y1=" ` +y +`" x1="0" y2="` +y +`" x2="`+panelWidth+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>                                  `;
		        }

		        if(neighbourCmp.y + neighbourCmp.height /2 == y + componentMiddleHeight){
		            svgContent+= `<line y1=" ` +(y+componentMiddleHeight) +`" x1="0" y2="` +(y + componentMiddleHeight) +`" x2="`+panelWidth+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>`;
		        }
		        if(neighbourCmp.y + neighbourCmp.height == y + componentHeight){
		            svgContent+= `<line y1=" ` +(y + componentHeight) +`" x1="0" y2="` +(y + componentHeight) +`" x2="`+panelWidth+`" style="stroke:black;stroke-width:1" stroke-dasharray="5 20"></line>`;
		        }
		    }
		}
		svgContent+=`</svg>`;

		// make wrapper that hosts this dom and add it to content
		var wrapper;
		var prevWrapper = document.getElementById("lineWrapper");
		if(prevWrapper){
		    // repurpose old wrapper to host new content
		    wrapper = prevWrapper;
		}
		else{
		    wrapper= document.createElement('div'); // create wrapping div

		}
		wrapper.setAttribute("id", "lineWrapper"); // set its id
		wrapper.innerHTML= svgContent; //insert string content




		//refs.panelContent.el.dom.firstChild.firstChild.firstChild.appendChild(wrapper);

		refs.panelContent.el.dom.firstChild.firstChild.firstChild.insertAdjacentElement('afterbegin', wrapper);
	},

	createSelection: function(opts) {
		// gets called when user creates new component - by duplicate or create new
		var text = opts.text,
		    answers = opts.answers,
		    multi = opts.multi,
		    component = opts.component;

		if(answers.length === 0) {
		    return 'Please specify at least one answer';
		}
		if(answers.filter(function(item) { return item.correct; }).length === 0) {
		    return 'Please mark at least one answer as correct';
		}
		if(!multi && answers.filter(function(item) { return item.correct; }).length > 1) {
		    return 'Only one correct answer is allowed for single selection';
		}

		var me = this;

		// Testing selection insert Jernej Habjan 2018-07-16

		var questionsStore = me.getStore('QuestionsStoreSlides'),
			treeStoreSlides = me.getStore('TreeStoreSlides');

		// getting all correct answers
		var correctAnswersIds = []; // this array stores ids of correct answers, where ids are generated as sequence numbers

		for (var i = 0; i < answers.length; i++) {
		    var element = answers[i];
		    if (element.correct === true){
		        correctAnswersIds.push(element.id); // adds sequence number of this question
		    }
		}

		// getting page id
		var refs = this.getReferences(),
		    selection = me.getCurrentSlide();

		if(!selection){
			me.newSlide();
			selection = me.getCurrentSlide();
		}


		var pageGuid = selection.data.id;
		var componentGuid = createGUID();

		var now = new Date();

		var record = {
		    id : componentGuid,
		    pageId: pageGuid,
		    question: text,
			created : now,
			lastChanged: now,
		    answers:Ext.encode(answers),
		    correctValue: Ext.encode(correctAnswersIds),
		    fieldType:  (multi? "Multi" : "Single") + " " + me.cmpTypes.SELECTION
		    // this renders to string "Multi selection" or "Single selection"

		};

		//adding new record to store
		var rec = questionsStore.add(record)[0];
		rec.data.lastChanged = new Date();
		rec.phantom = true; // phantom has to be set to true because main property in Question model is id!!!


		treeStoreSlides.findRecord('id', me.getCurrentSlide().id).phantom = true;



		// WATCH OUT - save state before rendering components, so data from store is saved to localstorage and from there data can be rendered in insert cmp
		//me.saveState(); // TODO - is it necessarry ???



		// after adding to database add component to view
		if(component) {
		    var state = component._opts;
		    me.deleteComponent(component, false);
		    state.html = text;
		    state.options = answers;
		    state.id =  componentGuid;
		    component = me.insertComponent(state);
		}
		else {
		    component = me.insertComponent({
		        type: me.cmpTypes.SELECTION,
		        cls: 'selection',
		        html: text,
		        options: answers,
		        multi: multi,
		        id: componentGuid,
		        width: opts.width,
		        height: opts.height
		    });
		}

		 me.saveState();


	},

	createResizer: function(cmp) {

		var me = this,
		    snap = me._pageSetup.snap;

		cmp._resizer = Ext.create('Ext.create', 'Ext.resizer.Resizer', {
		    target: Ext.get(cmp),
		    //pinned:true,
		    minWidth: snap,
		    minHeight: snap,
		    heightIncrement: snap,
		    widthIncrement: snap,
		    preserveRatio: false,
		    dynamic: true,
		    transparent: false,
		    handles: 'all', // shorthand for 'n s e w ne nw se sw'
		    listeners: {
		        beforeresize: function(component){
		            component.el.fireEvent('click');
		        },

		        resizedrag:function(component, width, height){
		            component.el._opts.width = width;
		            component.el._opts.height = height;
		            component.el._opts.x = component.el.dom.offsetLeft;
		            component.el._opts.y = component.el.dom.offsetTop;
		            me.drawHelperLines(component);

		            me.showComponentTools(component);
		        },


		        resize: function (component, width, height, e, eOpts) {
		            var prevWrapper = document.getElementById("lineWrapper");
		            if(prevWrapper){
		                prevWrapper.outerHTML = ""; // remove old wrapper
		            }
		            cmp.width = width;
		            cmp.height = height;
		            cmp._opts.width = width;
		            cmp._opts.height = height;

		            // save slide state after resizing element

		            var id = component.target._opts.id; // TODO - this line is changed as of in the dragmove function
		            var currentSlide = me.getCurrentSlide();

		            // THIS FUNCTION NOW WORKS FOR ALL - IMAGES, AUDIO, SELECTIONS, BECAUSE EVERYONE HAS ITS OWN ID

		            // set new info to this new altered component
		            var alteredContent = Ext.decode(currentSlide.data.content);
		            for (var key in alteredContent.components){
		                if(alteredContent.components[key].id == id){

		                    // resizer changes width, height and also x,y
		                    alteredContent.components[key].width = me.round(width); // Todo these lines are changes ofc
		                    alteredContent.components[key].height = me.round(height);

		                    alteredContent.components[key].x = me.round(component.target.dom.offsetLeft);
		                    alteredContent.components[key].y = me.round(component.target.dom.offsetTop);
		                }
		            }
		            // change store and sync
		            var storeItems = me.getStore('TreeStoreSlides').data.items;
		            for(var i = 0; i < storeItems.length; i++){
		                if(storeItems[i].id == currentSlide.id){
		                    storeItems[i].data.content = Ext.encode(alteredContent);
		                    storeItems[i].data.lastChanged = new Date();
		                    storeItems[i].phantom = true;
		                    break;
		                }
		            }
		            me.saveState();
		        }
		    }
		});

	},

	serverSync: function(callback) {
		// calls sync of everything (slides, questions, answers, pageConfig...) - it retrieves data and pushes latest data to server

		// syncs all data with server - this is called on program load and on navigator onLine

		var me = this,
		    localStorageData = Ext.decode(localStorage.getItem('mxp_elearning'))[me.programId];

		var syncQuestionsCallback = function(){
		    // after loading slides, load questions

			if(me.currentPersonProgram){
				//var params = {programId: me.currentPersonProgram.personTrainingProgramId}; //get all data from current person program id
				var params = {programId: me.programId};
				me.initialDataSync('PersonAnswers', 'answers', params, callback, 'id');
			}
			else{
				if (callback){ callback(); }
			}
		};
		var syncStateCallback = function(){
		    var params = {programId: me.programId};
		    me.initialDataSync('QuestionsStoreSlides', 'questions', params, syncQuestionsCallback, 'id');

		};
		// number 1

		if(localStorageData.pageSetup){ // TODO retrieve it later from database
		    me._pageSetup = localStorageData.pageSetup;
		}
		var params = {programId: me.programId};
		me.initialDataSync('TreeStoreSlides', 'slides', params, syncStateCallback, 'id');
	},

	renderThumbnails: function() {
		// TODO - Jernej Habjan 2018-07-12
		// Trying to replace slide icon in treeview by rendered content


		// todo - check if there are any children - possible crash here

		// get all currently shown nodes in tree view - only parent of collapsed nodes is visible
		var treeView = refs.treeSlides.el.dom.children[0].children[1].children[0].children[1].children;
		for (var i=0, n=treeView.length; i < n; i++){

		    var children = treeView[i].children[0].children[0].children[0].children[0].children;

		    var slide = children[children.length - 2]; // slots before that occupy indents in tree view, slot after that is text



		    // uncomment this if to allow rendering on all tree nodes - and not only on slides
		    if(slide.classList.contains("x-tree-icon-leaf")){ // check if it is slide
		        slide.outerHTML = '<div role="presentation" class="  x-tree-icon"><img src="https://www.vaporfi.com.au/media/catalog/product/cache/34/thumbnail/600x600/9df78eab33525d08d6e5fb8d27136e95/v/z/vz_eliquid_juicy_red_apple.jpg" style="width:20px; height:20px;"></div>';

		        // Todo - replace apple photo with rendered slide with scale of 20, 20


		    }

		}

		// Part 2 - rendering slides in appropriate slots:
		var data = Ext.decode(localStorage.getItem('mxp_elearning')[me.programId][me.slideId]);
		for (var key in data.slides){
			var value = data.slides[key];
			if(value.isSlide){
				console.log("printing slide",value);
			}
		}


		// Part 3 - slide html to canvas - http://html2canvas.hertzen.com/

		document.body.innerHTML += '<div id="capture" style="padding: 10px; background: #f5da55">    <h4 style="color: #000; ">Hello world!</h4></div>';

		html2canvas(document.querySelector("#capture")).then(canvas => {
		    document.body.appendChild(canvas);
		});


	},

	close: function(owner, tool, event) {
		var me = this;
		var yesCallback = function(){ // if user selects yes on close preview, set active item to programs, else do nothing
			me.getView().up('#mainView').setActiveItem('gridPrograms');

			// clear all stores so next program we are viewing wont be using this programs data
			// to silently remove data from store - use loadData([],false) !!
			// remove all data from these stores - silently
			me.getStore('TreeStoreSlides').loadData([],false);
			me.getStore('QuestionsStoreSlides').loadData([],false);
			me.getStore('PersonAnswers').loadData([],false);
			me.getStore('PersonPrograms').loadData([],false);
		};

		if(me.previewing){ // only if we are previewing show close dialog
			me.togglePreview(false, yesCallback); // show close dialog for preview
		}else{
			// if we are not previewing, its safe to call yesCallback
			yesCallback();
		}
	},

	onTreeViewDragDrop: function(treeviewdragdrop) {
		var me = this,
			refs = me.getReferences();

		var treeStoreSlides = me.getStore('TreeStoreSlides');

		// we need to mark every slide as dirty, as we cannot know how the selection was changed
		for (var i = 0; i < treeStoreSlides.data.items.length; i++){
			var rec = treeStoreSlides.data.items[i];
			rec.dirty = true;
		}
		me.saveState();
		refs.treeSlides.setSelection(me.getCurrentSlide());

	},

	onTreeSlidesSelect: function(rowmodel, record, index, eOpts) {
		// loading slide state for both sections and slides, because creating title every time caused sync with database

		var me = this,
			refs = me.getReferences();

		me.loadSlideState(record);

		// if(record.isLeaf()) {
		//     this.loadSlideState(record);
		// }
		// else {
		//     this.clearSlidePanel();
		//
		//     // Todo -insert title is causing another sync with database
		//     this.insertTitle('Section ' + record.get('title'));
		// }

	},

	onTreeSlidesDeselect: function(rowmodel, record, index, eOpts) {
		this.clearSlidePanel();
	},

	onEditSlidesBoxReady: function(component, width, height, eOpts) {
		var me = this,
			refs = me.getReferences();

		me.previewing = false; // used for toggling event actions when previewing or not

		me._pageSetup = {
			snap: 25,
			width: 800,
			height: 600,
			headerHeight: 50,
			footerHeight: 50,
			padding: 50,
			background: null
		};

		me.cmpTypes = {
			HTML: 'html',
			TITLE: 'title',
			TEXT: 'text',
			IMAGE: 'image',
			AUDIO: 'audio',
			VIDEO: 'video',
			SELECTION: 'selection'
		};

		refs.panelContent.removeAll();
		refs.toolbarPreview.hide();


		component.el.on('click', function(e, t) {
			// hiding component tools if component itself (like bodyPanel, ImageComponent...) didn't stop click event to backpropagate

			if(!e.ctrlKey && !e.shiftKey){

				// if we clicked on background without holding shift or ctrl key - remove all selected components
				// if we are holding shift or ctrl key, we are multiselecting and we might have clicked on background by accident
				me.hideComponentTools();

				for(var i = 0; i < me.allComponents.length; i++){
					me.allComponents[i].fireEvent('deselect');
				}
				me._selectedComponents = [];
			}



		});

		document.addEventListener("keydown", function onPress(event) {
			var KEY_DELETE = 46;
			var KEY_A = 65;
			if(me._selectedComponents.length){
				if(event.keyCode === KEY_DELETE){
					for(var i = 0; i < me._selectedComponents.length; i++){
						var cmp = me._selectedComponents[i];
						cmp.fireEvent('_delete');
					}
					me.hideComponentTools();

				}
			}
			if(event.keyCode === KEY_A){
				if (event.ctrlKey) {
					// clear all selected components
					me._selectedComponents = [];
					if(!me.previewing && me.allComponents.length){
						me._selectedComponents = me.allComponents; //select all components
						// iterate through all components - they are getting reset on slide deselect and on editSlides load
						for(var i = 0; i < me.allComponents.length; i++){
							me.allComponents[i].addCls('selected');
						}
						me.showComponentTools( me.allComponents[ me.allComponents.length-1]);
					}
				}
				event.preventDefault();
			}
		});



		// create online / offline event listenere - when coming back online, we want to sync localstorage with database
		function connectionChange() {
			if (navigator.onLine){
				var callback = function(){
					var currentSlide = me.getCurrentSlide();
					me.getReferences().treeSlides.setSelection(null);
					me.getReferences().treeSlides.setSelection(currentSlide); // retrigger current slide to update
					me.saveState(); // save ALL data that is after all initial data syncs to localstorage
					Ext.toast('Welcome back online! Content saved on server.');
				};


				me.serverSync(callback); // calls sync of everything (slides, questions, answers, pageConfig...) - it retrieves data and pushes latest data to server




			}else{
				Ext.toast('We went offline! Content is still saved locally. Reconnect to save content with server.');
			}
		}
		// Update the online status icon based on connectivity
		window.addEventListener('online',  connectionChange);
		window.addEventListener('offline', connectionChange);

		// add eventlistenere on fullscreen change to remove this panel on fullscreen off
		var me = this;
		var screen_change_events = ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "MSFullscreenChange"];

		for (var i in screen_change_events){
			document.addEventListener(screen_change_events[i], function( event ) {
				// The event object doesn't carry information about the fullscreen state of the browser,
				// but it is possible to retrieve it through the fullscreen
				if (document.webkitFullscreenElement ||  document.fullscreenElement || document.mozFullscreenElement || document.msFullscreenElement ) {
				}else{
					// The target of the event is always the document,
					// but it is possible to retrieve the fullscreen element through the API
					refs.slideNavigation.getController().closeFullscreen();
				}
			});
		}

	}

});
